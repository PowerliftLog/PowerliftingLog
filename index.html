<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>PowerliftingLog</title>
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAlElEQVR4nO2X0QmAMBBDU/GrW+koDuYoOpp+FUTwwyQQlGaA3nvX3kFLrfVAMEOyeAf4F8C+zlkANhYA1t4GAADTsmUAFHsLgBoJQLWXAVrY+5cAHPYAMDoOucK87QbVgSd75iq+NwVOe4B4A/dC0UXUikfG0BUZQLGXAFyLSOqAai8DOEJvQoc9DeBM6V+zDpAGOAEoFSO7lhfbZgAAAABJRU5ErkJggg==">
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@400;600;700;900&family=Barlow:wght@400;500;600&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html { background: #0a0a0a; }
body { background: #0a0a0a; color: #f0f0f0; font-family: 'Barlow', sans-serif; min-height: 100vh; -webkit-font-smoothing: antialiased; }
.app { max-width: 480px; margin: 0 auto; min-height: 100vh; }
.header { padding: 18px 16px 14px; border-bottom: 1px solid rgba(255,255,255,0.06); display: flex; align-items: center; justify-content: space-between; position: sticky; top: 0; background: rgba(10,10,10,0.95); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); z-index: 100; }
.header-logo { font-family: 'Barlow Condensed', sans-serif; font-weight: 900; font-size: 22px; letter-spacing: 0.04em; color: #C9A84C; }
.header-sub { font-size: 10px; color: #666; letter-spacing: 0.12em; text-transform: uppercase; margin-top: 3px; }
.new-btn { font-size: 11px; font-weight: 600; color: #888; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 7px 13px; cursor: pointer; font-family: 'Barlow Condensed', sans-serif; letter-spacing: 0.06em; text-transform: uppercase; transition: all 0.15s; }
.upload-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 80vh; padding: 32px 24px; text-align: center; }
.upload-icon { width: 80px; height: 80px; border: 2px solid #C9A84C; border-radius: 18px; display: flex; align-items: center; justify-content: center; margin-bottom: 28px; font-size: 32px; }
.upload-title { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 30px; margin-bottom: 10px; }
.upload-desc { color: #555; font-size: 14px; line-height: 1.7; margin-bottom: 36px; max-width: 280px; }
.upload-btn { background: #C9A84C; color: #fff; border: none; padding: 17px 32px; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 20px; letter-spacing: 0.06em; border-radius: 10px; cursor: pointer; width: 100%; max-width: 300px; }
.upload-btn:active { opacity: 0.85; }
.upload-divider { display: flex; align-items: center; gap: 12px; width: 100%; max-width: 300px; margin: 16px 0; }
.upload-divider::before, .upload-divider::after { content: ''; flex: 1; height: 1px; background: #222; }
.upload-divider span { font-size: 12px; color: #444; text-transform: uppercase; letter-spacing: 0.08em; }
.drive-btn { background: #1a1a1a; color: #f0f0f0; border: 1px solid #333; padding: 17px 32px; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 20px; letter-spacing: 0.06em; border-radius: 10px; cursor: pointer; width: 100%; max-width: 300px; display: flex; align-items: center; justify-content: center; gap: 10px; }
.drive-btn:active { opacity: 0.85; }
.block-bar { padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; justify-content: space-between; background: rgba(255,255,255,0.02); }
.block-name { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; letter-spacing: 0.03em; color: #e8e8e8; }
.block-dates { font-size: 11px; color: #666; margin-top: 3px; letter-spacing: 0.03em; }
.cycle-select { background: rgba(255,255,255,0.05); color: #888; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 6px 10px; font-size: 12px; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; letter-spacing: 0.04em; outline: none; max-width: 160px; cursor: pointer; }
.maxes-bar { display: flex; border-bottom: 1px solid #222; }
.max-item { flex: 1; padding: 10px 0; text-align: center; border-right: 1px solid #222; }
.max-item:last-child { border-right: none; }
.max-lift { font-size: 10px; color: #555; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 2px; }
.max-weight { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 20px; color: #C9A84C; }
.week-bar { display: flex; gap: 8px; padding: 12px 16px; overflow-x: auto; border-bottom: 1px solid rgba(255,255,255,0.05); scrollbar-width: none; background: rgba(255,255,255,0.01); }
.week-bar::-webkit-scrollbar { display: none; }
.week-pill { flex-shrink: 0; padding: 8px 20px; border-radius: 100px; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; font-size: 14px; letter-spacing: 0.04em; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.04); color: #666; cursor: pointer; white-space: nowrap; max-width: 160px; overflow: hidden; text-overflow: ellipsis; transition: all 0.15s; box-shadow: 0 1px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05); }
.week-pill.active { background: rgba(201,168,76,0.1); color: #C9A84C; border-color: rgba(201,168,76,0.6); border-width: 1.5px; box-shadow: 0 1px 8px rgba(201,168,76,0.15), inset 0 1px 0 rgba(201,168,76,0.1); }
.day-tabs { display: flex; border-bottom: 1px solid rgba(255,255,255,0.05); overflow-x: auto; scrollbar-width: none; background: rgba(255,255,255,0.01); }
.day-tabs::-webkit-scrollbar { display: none; }
.day-tab { flex-shrink: 0; padding: 12px 14px; text-align: center; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; font-size: 13px; letter-spacing: 0.06em; text-transform: uppercase; color: #666; border: none; background: transparent; cursor: pointer; border-bottom: 2px solid transparent; position: relative; white-space: nowrap; transition: color 0.15s; }
.day-tab.active { color: #C9A84C; border-bottom-color: #C9A84C; background: linear-gradient(180deg, rgba(201,168,76,0.06) 0%, transparent 100%); }
.done-dot { position: absolute; top: 3px; right: 4px; font-size: 11px; color: #4ade80; line-height: 1; }
.exercises { padding: 12px 16px 120px; }
.exercise-card { background: linear-gradient(160deg, #1c1c1c 0%, #141414 60%, #111 100%); border: 1px solid rgba(255,255,255,0.07); border-radius: 14px; margin-bottom: 10px; overflow: hidden; transition: border-color 0.2s; box-shadow: 0 2px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05); }
.superset-group { border: 1px solid #2a2a1a; border-radius: 12px; margin-bottom: 12px; overflow: hidden; background: #0e0e0e; }
.superset-header { display: flex; align-items: center; gap: 8px; padding: 7px 14px; background: #161610; border-bottom: 1px solid #2a2a1a; }
.superset-badge { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 11px; letter-spacing: 0.08em; text-transform: uppercase; color: #C9A84C; background: rgba(201,168,76,0.1); border: 1px solid rgba(201,168,76,0.2); border-radius: 4px; padding: 2px 8px; }
.superset-label { font-size: 11px; color: #444; font-family: 'Barlow', sans-serif; }
.superset-group .exercise-card { border-radius: 0; border-left: 3px solid rgba(201,168,76,0.2); border-right: none; border-top: none; border-bottom: 1px solid #1a1a1a; margin-bottom: 0; background: #111; }
.superset-group .exercise-card:last-child { border-bottom: none; }
.superset-group .exercise-card.completed { border-left-color: rgba(74,222,128,0.3); }
.superset-group .exercise-card.skipped { border-left-color: rgba(255,255,255,0.05); }
.exercise-card.completed { border-color: rgba(74,222,128,0.25); box-shadow: 0 2px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(74,222,128,0.06); }
.exercise-card.skipped { border-color: rgba(255,255,255,0.04); box-shadow: none; }
.exercise-card.skipped .ex-summary-name { text-decoration: line-through; color: #3a3a3a; }
.exercise-card.skipped .ex-summary-pres { color: #2a2a2a; }
.exercise-card.skipped .track-btn { color: #1e1e1e; }
.exercise-card.skipped .track-btn.tracked { color: #C9A84C; }
.exercise-card.skipped .exercise-name { text-decoration: line-through; color: #555; }
.ex-summary { display: flex; align-items: center; justify-content: space-between; padding: 13px 16px; cursor: pointer; gap: 8px; user-select: none; }
.ex-summary-left { display: flex; flex-direction: column; gap: 3px; flex: 1; min-width: 0; }
.ex-summary-name { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; letter-spacing: 0.02em; line-height: 1.15; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ex-summary-name.done { color: #888; }
.ex-summary-name.skipped { text-decoration: line-through; color: #555; }
.ex-summary-pres { font-family: 'Barlow Condensed', sans-serif; font-size: 14px; color: #666; letter-spacing: 0.02em; }
.ex-summary-right { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
.ex-expand-icon { color: #444; transition: transform 0.15s; line-height: 1; display: flex; align-items: center; }
.ex-expand-icon svg { width: 14px; height: 14px; }
.ex-expand-icon.open { transform: rotate(180deg); }
.ex-detail { border-top: 1px solid rgba(255,255,255,0.05); }
.skip-btn { font-size: 11px; color: #666; background: none; border: 1px solid #333; border-radius: 5px; padding: 4px 8px; cursor: pointer; font-family: 'Barlow', sans-serif; letter-spacing: 0.04em; text-transform: uppercase; transition: all 0.15s; flex-shrink: 0; }
.skip-btn.active { color: #aaa; border-color: #555; background: #1a1a1a; }
.skip-row { padding: 0 16px 14px; display: flex; justify-content: flex-end; gap: 8px; }
.set-adjust-btn { font-size: 11px; color: #666; background: none; border: 1px solid #333; border-radius: 5px; padding: 4px 8px; cursor: pointer; font-family: 'Barlow', sans-serif; letter-spacing: 0.04em; text-transform: uppercase; transition: all 0.15s; flex-shrink: 0; }
.set-adjust-btn:active { color: #C9A84C; border-color: #C9A84C; }
.skipped-badge { font-size: 10px; color: #555; font-family: 'Barlow', sans-serif; letter-spacing: 0.06em; text-transform: uppercase; border: 1px solid #2a2a2a; border-radius: 4px; padding: 2px 6px; }
.edit-name-btn { background: none; border: none; cursor: pointer; font-size: 12px; opacity: 0.0; padding: 2px 4px; transition: opacity 0.15s; flex-shrink: 0; line-height: 1; }
.exercise-card:hover .edit-name-btn { opacity: 0.4; }
.exercise-name-edit { flex: 1; background: #1e1e1e; border: 1px solid #C9A84C; border-radius: 6px; color: #f0f0f0; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 20px; padding: 4px 8px; outline: none; min-width: 0; width: 100%; }
.block-name-edit { background: #1e1e1e; border: 1px solid #C9A84C; border-radius: 6px; color: #f0f0f0; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 17px; padding: 3px 8px; outline: none; width: 100%; letter-spacing: 0.04em; }
.exercise-header { padding: 14px 16px 10px; display: flex; align-items: flex-start; justify-content: space-between; gap: 8px; }
.exercise-name { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 20px; letter-spacing: 0.02em; line-height: 1.15; flex: 1; }
.exercise-check { width: 30px; height: 30px; border-radius: 50%; border: 1.5px solid #2a2a2a; background: transparent; color: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 13px; flex-shrink: 0; margin-top: 2px; transition: all 0.15s; }
.exercise-check.done { background: rgba(74,222,128,0.1); border-color: rgba(74,222,128,0.5); color: #4ade80; }
.prescription { padding: 0 16px 12px; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 20px; color: #C9A84C; letter-spacing: 0.03em; }
.prescription.purple { color: #C9A84C; }
.sets-grid { padding: 4px 14px 14px; display: flex; flex-direction: column; gap: 0; }
.set-row { display: flex; align-items: center; gap: 8px; padding: 7px 2px; border-bottom: 1px solid #1a1a1a; }
.set-row:last-child { border-bottom: none; }
.set-num { font-family: 'Barlow Condensed', sans-serif; font-size: 11px; color: #3a3a3a; width: 18px; flex-shrink: 0; }
.set-prescribed { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 16px; color: #c0c0c0; min-width: 70px; flex-shrink: 0; white-space: nowrap; }
.set-inputs-wrap { display: flex; flex-direction: row; gap: 6px; flex: 1; }
.set-input-group { display: flex; flex-direction: column; gap: 2px; flex: 1; min-width: 0; }
.set-input-label { font-size: 9px; color: #3a3a3a; text-transform: uppercase; letter-spacing: 0.1em; padding-left: 1px; }
.set-input { background: #1a1a1a; border: 1px solid #222; border-radius: 7px; color: #f0f0f0; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 17px; padding: 7px 4px; width: 100%; text-align: center; outline: none; }
.set-input:focus { border-color: #C9A84C; background: #1e1c15; color: #fff; }
.set-input.rpe-input:focus { border-color: #C9A84C; background: #1e1c15; }
.set-input::placeholder { color: #282828; font-size: 11px; font-weight: 400; }
.prescribed-label { width: 80px; text-align: center; font-size: 12px; color: #333; }
.set-check { width: 32px; height: 32px; border-radius: 50%; border: 1.5px solid #222; background: transparent; color: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; transition: all 0.15s; }
.set-check.done { background: rgba(74,222,128,0.12); border-color: #4ade80; color: #4ade80; }
.coach-note { padding: 8px 16px; background: rgba(26,26,10,0.8); border-top: 1px solid #2a2a18; font-size: 12px; color: #a8a850; font-style: italic; }
.notes-section { border-top: 1px solid #1a1a1a; }
.notes-label { font-size: 10px; color: #555; text-transform: uppercase; letter-spacing: 0.08em; padding: 8px 16px 4px; display: flex; align-items: center; gap: 5px; }
.notes-label svg { width: 12px; height: 12px; flex-shrink: 0; }
.upload-icon svg { width: 48px; height: 48px; }
.edit-name-btn svg { width: 12px; height: 12px; vertical-align: middle; }
.clear-workout-btn svg { width: 16px; height: 16px; vertical-align: middle; }
.program-delete-btn svg { width: 14px; height: 14px; vertical-align: middle; }
.next-workout-banner-text svg { width: 10px; height: 10px; vertical-align: middle; margin-right: 2px; }
.calc-no-solution svg { width: 14px; height: 14px; vertical-align: middle; }
.notes-area { padding: 0 16px 12px; }
.notes-input { width: 100%; background: #1a1a1a; border: 1px solid #222; border-radius: 6px; color: #888; font-family: 'Barlow', sans-serif; font-size: 13px; padding: 8px 10px; resize: none; outline: none; min-height: 36px; }
.notes-input:focus { border-color: #333; color: #f0f0f0; }
.notes-input::placeholder { color: #555; }
.lifter-prev-note { padding: 0 16px 6px; font-size: 12px; color: #666; font-style: italic; }
.prev-performance { border-top: 1px solid #1a1a1a; padding: 8px 16px 10px; }
.prev-performance-label { font-size: 10px; color: #555; text-transform: uppercase; letter-spacing: 0.08em; padding-bottom: 6px; }
.prev-performance-sets { display: flex; flex-wrap: wrap; gap: 6px; }
.prev-performance-set { font-size: 12px; color: #777; background: rgba(255,255,255,0.04); padding: 3px 8px; border-radius: 4px; font-family: 'Barlow Condensed', sans-serif; letter-spacing: 0.02em; }
.rest-msg { text-align: center; color: #333; padding-top: 60px; font-family: 'Barlow Condensed', sans-serif; font-size: 20px; }
.complete-workout-btn { display: block; width: calc(100% - 32px); margin: 8px 16px 24px; padding: 16px; background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 10px; color: #777; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; letter-spacing: 0.06em; cursor: pointer; text-align: center; transition: all 0.15s; }
.complete-workout-btn:active { background: #1e1e1e; border-color: rgba(74,222,128,0.4); color: #4ade80; }
.workout-complete-msg { text-align: center; color: #4ade80; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 16px; letter-spacing: 0.08em; padding: 20px 16px 32px; opacity: 0.6; display: flex; align-items: center; justify-content: center; gap: 10px; animation: completePulse 1.2s ease-out forwards; }
@keyframes completePulse {
  0%   { opacity: 0; text-shadow: 0 0 0px rgba(74,222,128,0); }
  30%  { opacity: 1; text-shadow: 0 0 20px rgba(74,222,128,0.8), 0 0 40px rgba(74,222,128,0.4); }
  70%  { opacity: 0.8; text-shadow: 0 0 10px rgba(74,222,128,0.4); }
  100% { opacity: 0.6; text-shadow: none; }
}
.clear-workout-btn { background: none; border: none; cursor: pointer; font-size: 16px; opacity: 0.5; padding: 2px 4px; transition: opacity 0.15s; line-height: 1; }
.clear-workout-btn:hover { opacity: 1; }
.next-workout-banner { display: flex; align-items: center; justify-content: space-between; margin: 0 16px 10px; padding: 11px 14px; background: linear-gradient(135deg, #1c1c14 0%, #161610 100%); border: 1px solid rgba(201,168,76,0.2); border-radius: 10px; cursor: pointer; transition: border-color 0.15s; box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(201,168,76,0.07); }
.next-workout-banner:active { border-color: rgba(201,168,76,0.6); background: linear-gradient(135deg, #201e10 0%, #1a1a0e 100%); }
.next-workout-banner-text { font-family: 'Barlow Condensed', sans-serif; font-size: 13px; font-weight: 700; letter-spacing: 0.06em; color: #C9A84C; opacity: 0.9; }
.next-workout-banner-arrow { color: #C9A84C; font-size: 14px; opacity: 0.7; }

/* Tracking button */
.track-btn { background: none; border: none; cursor: pointer; padding: 2px; transition: transform 0.1s; line-height: 1; color: #2e2e2e; display: flex; align-items: center; gap: 3px; }
.track-btn.tracked { color: #C9A84C; }
.track-btn.is-comp { color: #2e2e2e; }
.track-btn.is-comp.tracked { color: #C9A84C; }
.track-btn:active { transform: scale(1.3); }
.track-btn svg { width: 18px; height: 18px; display: block; }
.track-hint { padding: 0 16px 10px; font-size: 11px; color: #444; font-style: italic; display: flex; align-items: center; gap: 5px; }
.track-hint svg { width: 12px; height: 12px; flex-shrink: 0; }
.track-hint-inline { font-size: 10px; color: #444; font-family: 'Barlow', sans-serif; letter-spacing: 0.06em; text-transform: uppercase; font-style: normal; }

/* Bottom nav */
.bottom-nav { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); width: calc(100% - 32px); max-width: 420px; background: #1e1e1e; border: 1px solid rgba(255,255,255,0.08); border-radius: 100px; display: flex; z-index: 200; padding: 5px; gap: 3px; box-shadow: 0 8px 32px rgba(0,0,0,0.7), 0 2px 8px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.06); }
.nav-btn { flex: 1; padding: 10px 0 9px; display: flex; flex-direction: column; align-items: center; gap: 5px; background: none; border: none; border-radius: 100px; cursor: pointer; color: #4a4a4a; font-family: 'Barlow Condensed', sans-serif; font-size: 10px; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; transition: color 0.15s, background 0.15s; }
.nav-btn.active { color: #C9A84C; background: rgba(201,168,76,0.14); box-shadow: inset 0 1px 0 rgba(201,168,76,0.15); }
.nav-icon { width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; }
.nav-icon svg { width: 22px; height: 22px; fill: currentColor; }

.metrics-export-btn { background: none; border: none; color: #555; cursor: pointer; padding: 4px 6px; display: flex; align-items: center; margin-left: auto; transition: color 0.15s; }
.metrics-export-btn:active { color: #C9A84C; }
.metrics-export-btn svg { width: 16px; height: 16px; }
.metrics-back-btn { background: none; border: 1px solid #333; border-radius: 100px; color: #888; font-family: 'Barlow Condensed', sans-serif; font-size: 14px; letter-spacing: 0.04em; padding: 6px 14px; cursor: pointer; transition: all 0.15s; }
.metrics-back-btn:active { border-color: #C9A84C; color: #C9A84C; }
.metrics-cycle-toggle { display: flex; gap: 8px; padding: 0 0 16px; }
.metrics-toggle-pill { flex: 1; padding: 8px 12px; border-radius: 100px; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; font-size: 14px; letter-spacing: 0.04em; border: 1px solid #222; background: transparent; color: #555; cursor: pointer; transition: all 0.15s; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.metrics-toggle-pill.active { color: #C9A84C; border-color: #C9A84C; border-width: 2px; }
.metrics-toggle-pill:active { opacity: 0.7; }
.metrics-drill-label { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; letter-spacing: 0.04em; color: #C9A84C; }
.metrics-cycle-hint { font-size: 11px; color: #333; text-align: center; padding: 0 0 12px; font-style: italic; letter-spacing: 0.04em; }
.program-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
.program-item:last-child { border-bottom: none; }
.program-item-info { display: flex; flex-direction: column; gap: 3px; flex: 1; cursor: pointer; }
.program-item-name { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 17px; letter-spacing: 0.02em; }
.program-item-name.active-cycle { color: #C9A84C; }
.program-item-meta { font-size: 11px; color: #666; }
.program-item-actions { display: flex; gap: 8px; align-items: center; }
.program-select-btn { font-size: 11px; padding: 5px 12px; border-radius: 100px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.03); color: #999; font-family: 'Barlow Condensed', sans-serif; cursor: pointer; letter-spacing: 0.04em; }
.program-select-btn.current { border-color: #C9A84C; color: #C9A84C; }
.program-delete-btn { background: none; border: none; color: #444; font-size: 18px; cursor: pointer; padding: 4px 6px; transition: color 0.15s; line-height: 1; }
.program-delete-btn:active { color: #f87171; }
.export-scope-picker { display: none; gap: 6px; margin-top: 6px; padding: 6px 0 2px; }
.export-scope-btn { flex: 1; padding: 6px 8px; border: 1px solid #2a2a2a; border-radius: 6px; background: none; color: #888; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 11px; letter-spacing: 0.05em; cursor: pointer; transition: all 0.15s; text-transform: uppercase; }
.export-scope-btn:hover { border-color: #C9A84C; color: #C9A84C; }

/* ── Export Modal ─────────────────────────────────────────────────────────── */
.export-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.75); z-index: 1000; display: flex; align-items: flex-end; justify-content: center; padding-bottom: env(safe-area-inset-bottom); }
.export-modal { background: #0f0f0f; border: 1px solid #222; border-radius: 18px 18px 0 0; width: 100%; max-width: 480px; padding: 20px 16px 32px; }
.export-modal-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 18px; }
.export-modal-title { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 16px; letter-spacing: .06em; text-transform: uppercase; color: #fff; }
.export-modal-close { background: none; border: none; color: #444; cursor: pointer; padding: 4px; line-height: 1; font-size: 20px; }
.export-modal-close:active { color: #fff; }
.export-card { background: #141414; border: 1px solid #222; border-radius: 12px; padding: 16px; margin-bottom: 10px; }
.export-card-header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
.export-card-icon { width: 36px; height: 36px; flex-shrink: 0; }
.export-card-info { flex: 1; }
.export-card-name { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 15px; letter-spacing: .04em; color: #fff; margin-bottom: 2px; }
.export-card-desc { font-size: 12px; color: #555; line-height: 1.4; }
.export-scope-toggle { display: flex; gap: 6px; margin-bottom: 12px; }
.export-scope-pill { flex: 1; padding: 7px 10px; border: 1px solid #2a2a2a; border-radius: 6px; background: none; color: #666; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 11px; letter-spacing: .06em; text-transform: uppercase; cursor: pointer; transition: all 0.15s; text-align: center; }
.export-scope-pill.active { border-color: #C9A84C; color: #C9A84C; }
.export-action-btn { width: 100%; padding: 11px; background: #C9A84C; border: none; border-radius: 8px; color: #000; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 13px; letter-spacing: .08em; text-transform: uppercase; cursor: pointer; transition: opacity 0.15s; }
.export-action-btn:active { opacity: 0.8; }
.metrics-screen { padding: 16px 16px 100px; }
.cycle-tabs { display: flex; gap: 8px; padding: 0 0 14px; overflow-x: auto; scrollbar-width: none; }
.cycle-tabs::-webkit-scrollbar { display: none; }
.cycle-tab { flex-shrink: 0; padding: 7px 18px; border-radius: 100px; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; font-size: 14px; letter-spacing: 0.04em; border: 1px solid #333; background: transparent; color: #555; cursor: pointer; white-space: nowrap; transition: all 0.15s; }
.cycle-tab.active { background: #C9A84C; color: #000; border-color: #C9A84C; }
.metrics-lift-group { margin-bottom: 20px; background: linear-gradient(160deg, #1c1c1c 0%, #141414 60%, #111 100%); border: 1px solid rgba(255,255,255,0.07); border-radius: 14px; overflow: hidden; box-shadow: 0 2px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05); }
.metrics-lift-header { padding: 14px 16px 12px; display: flex; align-items: center; justify-content: space-between; }
.metrics-lift-title { font-family: 'Barlow Condensed', sans-serif; font-weight: 900; font-size: 22px; letter-spacing: 0.04em; }
.metrics-best { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; color: #C9A84C; }
.metrics-best-label { font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.08em; text-align: right; }
.variation-tabs { display: flex; gap: 0; overflow-x: auto; scrollbar-width: none; border-top: 1px solid #1e1e1e; border-bottom: 1px solid #1e1e1e; }
.variation-tabs::-webkit-scrollbar { display: none; }
.variation-tab { flex-shrink: 0; padding: 8px 14px; font-size: 12px; color: #444; background: none; border: none; cursor: pointer; font-family: 'Barlow', sans-serif; white-space: nowrap; border-bottom: 2px solid transparent; transition: all 0.15s; }
.variation-tab.active { color: #a78bfa; border-bottom-color: #a78bfa; }
.chart-wrap { padding: 16px; }
.chart-empty { padding: 20px 16px; text-align: center; font-size: 13px; color: #333; font-style: italic; }
canvas.rm-chart { width: 100%; height: 140px; display: block; }
.rm-datapoints { padding: 0 16px 12px; display: flex; flex-direction: column; gap: 0; }
.rm-row { display: flex; align-items: center; justify-content: space-between; padding: 7px 0; border-bottom: 1px solid rgba(255,255,255,0.04); }
.rm-session { font-size: 12px; color: #777; }
.rm-value { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; color: #C9A84C; }
.rm-delta { font-size: 12px; margin-left: 6px; }
.rm-delta.up { color: #4ade80; }
.rm-delta.down { color: #f87171; }

/* Add lift button */
.add-lift-btn { display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; padding: 14px; background: none; border: 1px dashed #2a2a2a; border-radius: 12px; color: #444; font-family: 'Barlow Condensed', sans-serif; font-size: 17px; letter-spacing: 0.04em; cursor: pointer; margin-bottom: 16px; transition: all 0.15s; }
.add-lift-btn:hover { border-color: #444; color: #888; }
.add-lift-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 300; display: flex; align-items: flex-end; }
.add-lift-sheet { background: #141414; border-radius: 16px 16px 0 0; padding: 24px 20px 40px; width: 100%; max-width: 480px; margin: 0 auto; border-top: 1px solid #222; }
.add-lift-title { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 22px; margin-bottom: 16px; }
.add-lift-input { width: 100%; background: #1c1c1c; border: 1px solid #2a2a2a; border-radius: 8px; color: #f0f0f0; font-family: 'Barlow', sans-serif; font-size: 16px; padding: 12px 14px; outline: none; margin-bottom: 8px; }
.add-lift-input:focus { border-color: #C9A84C; color: #fff; }
.add-lift-group-label { font-size: 12px; color: #555; margin-bottom: 6px; }
.add-lift-groups { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; }
.group-pill { padding: 6px 14px; border-radius: 100px; border: 1px solid #2a2a2a; background: transparent; color: #555; font-size: 13px; cursor: pointer; font-family: 'Barlow', sans-serif; }
.group-pill.active { background: #a78bfa22; border-color: #a78bfa; color: #a78bfa; }
.add-lift-actions { display: flex; gap: 10px; }
.add-lift-cancel { flex: 1; padding: 12px; background: none; border: 1px solid #222; border-radius: 8px; color: #555; font-family: 'Barlow Condensed', sans-serif; font-size: 18px; cursor: pointer; }
.add-lift-confirm { flex: 2; padding: 12px; background: #C9A84C; border: none; border-radius: 8px; color: #fff; font-family: 'Barlow Condensed', sans-serif; font-size: 18px; font-weight: 700; cursor: pointer; }
.no-data-msg { padding: 60px 24px; text-align: center; color: #333; font-size: 14px; line-height: 1.7; }

/* Legend */
.var-legend { display: flex; flex-wrap: wrap; gap: 8px 16px; padding: 10px 16px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
.legend-item { display: flex; align-items: center; gap: 6px; }
.legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.legend-label { font-size: 12px; color: #999; }

/* Variation data sections */
.var-section { padding: 10px 16px 6px; border-top: 1px solid rgba(255,255,255,0.04); }
.var-section:first-child { border-top: none; }
.var-section-title { display: flex; align-items: center; gap: 7px; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 16px; letter-spacing: 0.04em; color: #bbb; text-transform: uppercase; margin-bottom: 8px; }
.var-section-drill { cursor: pointer; padding: 6px 8px; margin: -6px -8px 4px; border-radius: 6px; transition: background 0.15s; }
.var-section-drill:active { background: #1e1e1e; }

/* Method badges */
.method-badge { font-size: 10px; letter-spacing: 0.05em; padding: 2px 6px; border-radius: 4px; font-family: 'Barlow', sans-serif; }
.rpe-badge { color: #C9A84C; background: rgba(201,168,76,0.1); }
.est-badge { color: #444; background: rgba(255,255,255,0.04); }

/* ── CALCULATOR SCREEN ─────────────────────────────────────────────────────── */
.calc-screen { padding: 16px 16px 100px; }
.calc-mode-toggle { display: flex; background: linear-gradient(160deg, #1c1c1c 0%, #141414 60%, #111 100%); border: 1px solid rgba(255,255,255,0.07); border-radius: 12px; padding: 4px; margin-bottom: 16px; box-shadow: 0 2px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05); }
.calc-mode-btn { flex: 1; padding: 10px 8px; border: none; border-radius: 8px; background: transparent; color: #4a4a4a; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 14px; letter-spacing: 0.06em; text-transform: uppercase; cursor: pointer; transition: all 0.15s; }
.calc-mode-btn.active { background: rgba(201,168,76,0.15); color: #C9A84C; box-shadow: inset 0 0 0 1px rgba(201,168,76,0.3); }
.calc-section { background: linear-gradient(160deg, #1c1c1c 0%, #141414 60%, #111 100%); border: 1px solid rgba(255,255,255,0.07); border-radius: 14px; padding: 16px; margin-bottom: 14px; box-shadow: 0 2px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05); }
.calc-section-title { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 12px; letter-spacing: 0.12em; text-transform: uppercase; color: #666; margin-bottom: 14px; }
.calc-input-row { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; overflow: hidden; }
.calc-weight-input { flex: 1; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; color: #f0f0f0; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 32px; padding: 12px 16px; outline: none; text-align: center; -moz-appearance: textfield; }
.calc-weight-input::-webkit-outer-spin-button,
.calc-weight-input::-webkit-inner-spin-button { -webkit-appearance: none; }
.calc-weight-input:focus { border-color: #C9A84C; }

.calc-totals-display { display: flex; gap: 12px; margin-bottom: 16px; }
.calc-total-box { flex: 1; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.06); border-radius: 10px; padding: 12px 14px; text-align: center; }
.calc-total-val { font-family: 'Barlow Condensed', sans-serif; font-weight: 900; font-size: 28px; color: #C9A84C; line-height: 1; }
.calc-total-unit { font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.08em; margin-top: 3px; }
.calc-bar-wrap { display: flex; align-items: center; justify-content: center; margin: 8px 0 16px; overflow: visible; }
.calc-bar-svg { width: 100%; height: 160px; overflow: visible; }
.calc-plate-breakdown { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; }
.calc-plate-chip { display: flex; align-items: center; gap: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 8px 12px; }
.calc-plate-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
.calc-plate-label { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 15px; color: #f0f0f0; }
.calc-plate-count { font-family: 'Barlow Condensed', sans-serif; font-size: 13px; color: #777; }
.calc-bar-note { font-size: 12px; color: #555; text-align: center; margin-top: 8px; font-style: italic; }
.calc-no-solution { font-size: 14px; color: #f87171; text-align: center; padding: 16px 0; }
/* Manual mode plate grid */
.calc-plates-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.calc-plate-row { display: flex; align-items: center; gap: 4px; background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.05); border-radius: 8px; padding: 5px 6px; min-width: 0; }
.calc-plate-color-swatch { width: 8px; height: 28px; border-radius: 2px; flex-shrink: 0; }
.calc-plate-name { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 14px; flex: 1; min-width: 0; white-space: nowrap; }
.calc-plate-stepper { display: flex; align-items: center; gap: 0; flex-shrink: 0; }
.calc-stepper-btn { width: 28px; height: 28px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); color: #ccc; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.1s; line-height: 1; user-select: none; }
.calc-stepper-btn:active { background: #2a2a2a; border-color: #C9A84C; }
.calc-stepper-val { width: 32px; text-align: center; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 18px; color: #C9A84C; }
.calc-stepper-val.zero { color: #333; }
.calc-reset-btn { width: 100%; padding: 12px; background: none; border: 1px solid rgba(255,255,255,0.07); border-radius: 8px; color: #555; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 14px; letter-spacing: 0.06em; text-transform: uppercase; cursor: pointer; margin-top: 8px; transition: all 0.15s; }
.calc-reset-btn:active { border-color: #f87171; color: #f87171; }
.calc-bar-selector { display: flex; gap: 8px; margin-bottom: 16px; }
.calc-bar-btn { flex: 1; padding: 10px 8px; border: 1px solid rgba(255,255,255,0.07); border-radius: 10px; background: rgba(0,0,0,0.2); color: #666; font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 13px; letter-spacing: 0.04em; cursor: pointer; text-align: center; transition: all 0.15s; line-height: 1.3; }
.calc-bar-btn.active { border-color: #C9A84C; color: #C9A84C; background: rgba(201,168,76,0.08); }
.calc-bar-btn-sub { font-size: 11px; font-weight: 400; color: #555; display: block; margin-top: 2px; }
.calc-bar-btn.active .calc-bar-btn-sub { color: #8a6f30; }
.calc-collar-row { display: flex; align-items: center; justify-content: space-between; padding: 12px 14px; background: linear-gradient(160deg, #1c1c1c 0%, #141414 100%); border: 1px solid rgba(255,255,255,0.07); border-radius: 12px; margin-bottom: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
.calc-collar-label { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 15px; color: #aaa; }
.calc-collar-sub { font-size: 11px; color: #666; margin-top: 1px; }
.calc-collar-toggle { width: 44px; height: 24px; border-radius: 12px; background: #222; border: none; cursor: pointer; position: relative; transition: background 0.2s; flex-shrink: 0; }
.calc-collar-toggle.on { background: #C9A84C; }
.calc-collar-toggle::after { content: ''; position: absolute; top: 3px; left: 3px; width: 18px; height: 18px; border-radius: 50%; background: #555; transition: transform 0.2s, background 0.2s; }
.calc-collar-toggle.on::after { transform: translateX(20px); background: #fff; }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div>
      <div class="header-logo">PowerliftingLog</div>
      <div class="header-sub" id="athlete-name"></div>
    </div>
    <button class="new-btn" id="new-btn">Load Program</button>
  </div>
  <div id="main-content"></div>
  <nav class="bottom-nav">
    <button class="nav-btn active" id="nav-workout" onclick="setScreen('workout')">
      <span class="nav-icon"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.57 14.86L22 13.43 20.57 12 17 15.57 8.43 7 12 3.43 10.57 2 9.14 3.43 7.71 2 5.57 4.14 4.14 2.71 2.71 4.14l1.43 1.43L2 7.71l1.43 1.43L2 10.57 3.43 12 7 8.43 15.57 17 12 20.57 13.43 22l1.43-1.43L16.29 22l2.14-2.14 1.43 1.43 1.43-1.43-1.43-1.43L22 16.29l-1.43-1.43z"/></svg></span>Workout
    </button>
    <button class="nav-btn" id="nav-metrics" onclick="setScreen('metrics')">
      <span class="nav-icon"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5 9v11H1V9h4zm4-5v16H5V4h4zm4 8v8h-4v-8h4zm4-4v12h-4V8h4zm4-6v18h-4V2h4z"/></svg></span>Metrics
    </button>
    <button class="nav-btn" id="nav-calc" onclick="setScreen('calc')">
      <span class="nav-icon"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H6zm0 2h12v4H6V4zm0 6h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM6 14h2v2H6v-2zm4 0h2v2h-2v-2zm4 0h2v6h-2v-6zM6 18h2v2H6v-2zm4 0h2v2h-2v-2z"/></svg></span>Calculator
    </button>
  </nav>
</div>
<div class="add-lift-modal" id="add-lift-modal" style="display:none">
  <div class="add-lift-sheet">
    <div class="add-lift-title">Track a Lift</div>
    <input class="add-lift-input" id="add-lift-name" placeholder="Exercise name (e.g. Romanian Deadlift)" />
    <div class="add-lift-group-label">Group under:</div>
    <div class="add-lift-groups">
      <button class="group-pill active" data-group="squat" onclick="selectGroup(this)">Squat</button>
      <button class="group-pill" data-group="bench" onclick="selectGroup(this)">Bench</button>
      <button class="group-pill" data-group="deadlift" onclick="selectGroup(this)">Deadlift</button>
      <button class="group-pill" data-group="other" onclick="selectGroup(this)">Other</button>
    </div>
    <div class="add-lift-actions">
      <button class="add-lift-cancel" onclick="closeAddLift()">Cancel</button>
      <button class="add-lift-confirm" onclick="confirmAddLift()">Add Lift</button>
    </div>
  </div>
</div>

<!-- Program Manager Modal -->
<div class="add-lift-modal" id="program-modal" style="display:none" onclick="if(event.target===this)closeProgramModal()">
  <div class="add-lift-sheet" style="max-height:80vh;overflow-y:auto">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px">
      <div class="add-lift-title" style="margin-bottom:0">Programs</div>
      <button onclick="closeProgramModal()" style="background:none;border:none;color:#555;font-size:22px;cursor:pointer;padding:4px">×</button>
    </div>
    <!-- Add new section -->
    <div style="margin-bottom:20px">
      <div class="add-lift-group-label" style="margin-bottom:10px">Add New Program</div>
      <div style="display:flex;gap:8px">
        <button class="upload-btn" style="flex:1;padding:11px 14px;font-size:13px;letter-spacing:0.05em;display:flex;align-items:center;justify-content:center;gap:7px" onclick="closeProgramModal();document.getElementById('file-input').click()">UPLOAD FROM DEVICE<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" width="15" height="15"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></button>
        <button class="drive-btn" style="flex:1;padding:11px 14px;font-size:13px;letter-spacing:0.05em;display:flex;align-items:center;justify-content:center;gap:7px" onclick="closeProgramModal();openDrivePicker()">UPLOAD FROM DRIVE<img src="https://www.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png" style="width:15px;height:15px"></button>
      </div>
    </div>
    <!-- Existing cycles -->
    <div id="program-list"></div>
  </div>
</div>

<!-- Delete Confirm Modal -->
<div class="add-lift-modal" id="delete-modal" style="display:none">
  <div class="add-lift-sheet">
    <div class="add-lift-title" style="color:#f87171">Delete Program?</div>
    <div style="font-size:14px;color:#888;line-height:1.6;margin-bottom:20px">
      This will permanently delete <strong id="delete-modal-name" style="color:#f0f0f0"></strong> and all logged workout data for this cycle. This cannot be undone.
    </div>
    <div class="add-lift-actions">
      <button class="add-lift-cancel" onclick="closeDeleteModal()">Cancel</button>
      <button id="delete-confirm-btn" class="add-lift-confirm" style="background:#f87171;color:#000" onclick="confirmDeleteBlock()">Delete Forever</button>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept=".xlsx,.xls,.csv" style="display:none">

<script>
const _savedBlocks=loadBlocks()||[];
const state = { blocks:_savedBlocks, activeBlock:_savedBlocks[_savedBlocks.length-1]||null, activeWeek:0, activeDay:0, logs:loadLogs(), screen:'workout', metricsDrillBlock:null, customLifts:loadCustomLifts(), trackedLifts:loadTrackedLifts(), editingExKey:null, editingBlockName:false, expandedEx:new Set(), extraSets:{}, calc:{ mode:'target', inputUnit:'lbs', inputVal:'', barId:'standard', collarsOn:false, manualCounts:{ 25:0, 20:0, 15:0, 10:0, 5:0, 2.5:0, 1.25:0, 0.5:0, 0.25:0 } } };
// Restore nav position from last session
(function restoreNav(){
  const nav=loadNav();
  if(nav.blockId){ const b=state.blocks.find(b=>b.id===nav.blockId); if(b) state.activeBlock=b; }
  if(typeof nav.week==='number') state.activeWeek=nav.week;
  if(typeof nav.day==='number') state.activeDay=nav.day;
})();

// Re-run set-level pre-population for blocks restored from localStorage
// This fills in missing set keys that may not have existed in older versions
function loadLogs(){ try{ return JSON.parse(localStorage.getItem('liftlog_v4')||'{}'); }catch{ return {}; } }
let _saveLogsTimer=null;
function saveLogs(){ clearTimeout(_saveLogsTimer); _saveLogsTimer=setTimeout(()=>{ try{ localStorage.setItem('liftlog_v4', JSON.stringify(state.logs)); }catch(e){ console.error('[liftlog] saveLogs error:',e); } },300); }
function rePopulateSets(blocks){
  try{
    for(const block of blocks){
      if(block.format!=='A') continue;
      for(const week of block.weeks){
        for(const day of week.days){
          for(const ex of day.exercises){
            const key=[block.id,week.label,day.name,ex.name].join('||');
            const exLog=state.logs[key];
            if(!exLog?.done) continue;
            if(!ex.prescription) continue;
            const sets=parseSets(ex.prescription);
            sets.forEach((s,si)=>{
              const sk=key+`||s${si}`;
              if(state.logs[sk]){
                // Backfill RPE onto existing set entries that were migrated without it
                if(exLog.rpe && !state.logs[sk].rpe) state.logs[sk].rpe=exLog.rpe;
                return;
              }
              const setEntry={done:true};
              if(exLog.actual) setEntry.actual=exLog.actual;
              else if(!s.isRpe) setEntry.actual=String(s.weight);
              if(exLog.rpe) setEntry.rpe=exLog.rpe;
              state.logs[sk]=setEntry;
            });
          }
        }
      }
    }
    if(blocks.length>0) saveLogs();
  }catch(e){ console.error('[liftlog] rePopulateSets error:',e); }
}
if(_savedBlocks.length>0) rePopulateSets(_savedBlocks);
function loadBlocks(){ try{ const d=localStorage.getItem('liftlog_blocks'); return d?JSON.parse(d):null; }catch(e){ console.error('[liftlog] loadBlocks error:',e); return null; } }
function saveBlocks(){ try{ localStorage.setItem('liftlog_blocks',JSON.stringify(state.blocks)); }catch(e){ console.error('[liftlog] saveBlocks error:',e); } }
function loadCustomLifts(){ try{ return JSON.parse(localStorage.getItem('liftlog_custom')||'[]'); }catch{ return []; } }
function saveCustomLifts(){ try{ localStorage.setItem('liftlog_custom', JSON.stringify(state.customLifts)); }catch(e){ console.error('[liftlog] saveCustomLifts error:',e); } }
function loadTrackedLifts(){ try{ return JSON.parse(localStorage.getItem('liftlog_tracked')||'{}'); }catch{ return {}; } }
function saveTrackedLifts(){ try{ localStorage.setItem('liftlog_tracked', JSON.stringify(state.trackedLifts)); }catch(e){ console.error('[liftlog] saveTrackedLifts error:',e); } }
function loadNav(){ try{ return JSON.parse(localStorage.getItem('liftlog_nav')||'{}'); }catch{ return {}; } }
function saveNav(){ try{ localStorage.setItem('liftlog_nav', JSON.stringify({blockId:state.activeBlock?.id||null,week:state.activeWeek,day:state.activeDay})); }catch(e){ console.error('[liftlog] saveNav error:',e); } }
function lk(bid,wl,dn,en){ return [bid,wl,dn,en].join('||'); }
function esc(s){ return String(s).replace(/\\/g,'\\\\').replace(/'/g,"\\'"); }

// ── SCREEN NAV ────────────────────────────────────────────────────────────────
function setScreen(s){
  state.screen=s;
  if(s==='metrics') state.metricsDrillBlock=null;
  document.getElementById('nav-workout').classList.toggle('active',s==='workout');
  document.getElementById('nav-metrics').classList.toggle('active',s==='metrics');
  document.getElementById('nav-calc').classList.toggle('active',s==='calc');
  render();
}

// ── LIFT CLASSIFICATION ───────────────────────────────────────────────────────
const LIFT_GROUPS = {
  squat: ['squat','hack squat','goblet squat','front squat','zercher','belt squat','box squat','high bar squat','low bar squat','pin squat','pause squat','safety bar','ssb','1/4 squat','quarter squat','partial squat'],
  bench: ['bench','close grip bench','close grip press','larson','larsen','slingshot','incline press','incline bench','decline press','decline bench','floor press','feet up bench','pause bench','touch and go bench','touch and go press','tng bench','tng press','comp bench','board press'],
  deadlift: ['deadlift','sumo deadlift','sumo pull','sumo dead','conventional deadlift','conventional pull','romanian','rdl','rack pull','block pull','deficit deadlift','deficit pull','stiff leg','trap bar','hex bar','snatch grip','pause dead','semi sumo'],
};

// ── COMP LIFT DETECTION ───────────────────────────────────────────────────────
// Exact names that count as competition lifts for projections and default tracking.
// Variation modifiers disqualify a lift from being treated as a comp lift.
const COMP_KEYWORDS = {
  squat:    ['squat','back squat','low bar squat','barbell squat','comp squat','competition squat'],
  bench:    ['bench','bench press','barbell bench','barbell bench press','comp bench','comp bench press','competition bench','competition bench press','paused bench','paused bench press','pause bench','pause bench press'],
  deadlift: ['deadlift','barbell deadlift','conventional deadlift','sumo deadlift','comp deadlift','competition deadlift','conventional pull','sumo pull','comp pull','competition style deadlift'],
};

// These terms in a lift name disqualify it from being a comp lift
const VARIATION_MODIFIERS = [
  'pin','close grip','wide grip','tempo','incline','decline','deficit',
  'rack pull','block pull','snatch grip','stiff leg','romanian','rdl',
  'floor press','board press','slingshot','sling shot','feet up',
  'touch and go','tng','safety bar','ssb','zercher','front squat',
  'goblet','hack','belt squat','box squat','semi sumo',
  '1/4','quarter','partial',
  'pause squat','paused squat',
  'pause deadlift','paused deadlift','pause dead','paused dead',
];

function isCompLift(name){
  const n = name.toLowerCase().trim();
  // Variation modifier present → not a comp lift
  if (VARIATION_MODIFIERS.some(v => n.includes(v))) return false;
  // Exact match against comp keyword list
  for (const keywords of Object.values(COMP_KEYWORDS)) {
    if (keywords.includes(n)) return true;
  }
  return false;
}

function isTracked(name){
  // Returns true if this exercise should appear in metrics
  const n=name.toLowerCase().trim();
  if(state.trackedLifts[n]===false) return false; // explicitly deselected
  if(state.trackedLifts[n]===true) return true;   // explicitly opted in
  return isCompLift(name);                          // default: comp lifts on, variations off
}

function toggleTracked(name, event){
  if(event){ event.stopPropagation(); event.preventDefault(); }
  const n=name.toLowerCase().trim();
  const current=isTracked(name);
  state.trackedLifts[n]=!current;
  saveTrackedLifts();
  render();
}

// Auto-register comp lifts when a program is loaded
function autoRegisterCompLifts(blocks){
  for(const block of blocks){
    for(const week of block.weeks){
      for(const day of week.days){
        for(const ex of day.exercises){
          const n=ex.name.toLowerCase().trim();
          // Only set if not already explicitly set by user
          if(state.trackedLifts[n]===undefined&&isCompLift(ex.name)){
            state.trackedLifts[n]=true;
          }
        }
      }
    }
  }
  saveTrackedLifts();
}

function classifyLift(name){
  const n=name.toLowerCase();
  for(const [group,keywords] of Object.entries(LIFT_GROUPS)){
    if(keywords.some(k=>n.includes(k))) return group;
  }
  // Check custom lifts
  const custom=state.customLifts.find(c=>c.name.toLowerCase()===n);
  if(custom) return custom.group;
  return null;
}

// ── EXERCISE INPUT MODE ───────────────────────────────────────────────────────
const CARDIO_KEYWORDS = ['treadmill','bike','cycling','rowing machine','elliptical','stairmaster','stair master','cardio','walk','jog','run','sprint'];
const BODYWEIGHT_KEYWORDS = [
  'plank','sit up','situp','sit-up','crunch','leg raise','hanging leg','v-up','ab wheel','ab rollout',
  'dead bug','bird dog','pallof','push up','pushup','push-up','pull up','pullup','pull-up',
  'chin up','chinup','chin-up','dip','bodyweight','stretch','foam roll','mobility',
  'yoga','jumping jack','burpee','mountain climber','glute bridge','hip thrust bodyweight',
  'lunge bodyweight','pike','handstand','muscle up','muscle-up'
];
const TIMED_PATTERN=/\d+\s*(min|sec|s|m)\b/i;
function getExerciseInputMode(name,pres){
  const n=name.toLowerCase().trim();
  if(n.includes('weighted')) return 'weighted';
  if(CARDIO_KEYWORDS.some(k=>n.includes(k))) return 'cardio';
  if(BODYWEIGHT_KEYWORDS.some(k=>n.includes(k))){
    return (TIMED_PATTERN.test(n)||(pres&&TIMED_PATTERN.test(pres))) ? 'bw-timed' : 'bw';
  }
  return 'weighted';
}

// ── EPLEY 1RM ─────────────────────────────────────────────────────────────────
function epley(weight,reps){
  if(!weight||!reps||reps<1) return null;
  if(reps===1) return weight;
  return Math.round(weight*(1+reps/30));
}

// RTS RPE chart: maps reps @ RPE to % of 1RM
// RPE_TABLE[reps][rpe] = fraction of 1RM
const RPE_TABLE = {
  1:  {10:1.000, 9.5:0.978, 9:0.955, 8.5:0.939, 8:0.922, 7.5:0.907, 7:0.892, 6.5:0.878, 6:0.863, 5.5:0.849, 5:0.835},
  2:  {10:0.955, 9.5:0.939, 9:0.922, 8.5:0.907, 8:0.892, 7.5:0.878, 7:0.863, 6.5:0.849, 6:0.835, 5.5:0.822, 5:0.808},
  3:  {10:0.922, 9.5:0.907, 9:0.892, 8.5:0.878, 8:0.863, 7.5:0.849, 7:0.835, 6.5:0.822, 6:0.808, 5.5:0.794, 5:0.781},
  4:  {10:0.892, 9.5:0.878, 9:0.863, 8.5:0.849, 8:0.835, 7.5:0.822, 7:0.808, 6.5:0.794, 6:0.781, 5.5:0.768, 5:0.755},
  5:  {10:0.863, 9.5:0.849, 9:0.835, 8.5:0.822, 8:0.808, 7.5:0.794, 7:0.781, 6.5:0.768, 6:0.755, 5.5:0.742, 5:0.730},
  6:  {10:0.835, 9.5:0.822, 9:0.808, 8.5:0.794, 8:0.781, 7.5:0.768, 7:0.755, 6.5:0.742, 6:0.730, 5.5:0.717, 5:0.705},
  7:  {10:0.808, 9.5:0.794, 9:0.781, 8.5:0.768, 8:0.755, 7.5:0.742, 7:0.730, 6.5:0.717, 6:0.705, 5.5:0.693, 5:0.681},
  8:  {10:0.781, 9.5:0.768, 9:0.755, 8.5:0.742, 8:0.730, 7.5:0.717, 7:0.705, 6.5:0.693, 6:0.681, 5.5:0.669, 5:0.658},
  9:  {10:0.755, 9.5:0.742, 9:0.730, 8.5:0.717, 8:0.705, 7.5:0.693, 7:0.681, 6.5:0.669, 6:0.658, 5.5:0.647, 5:0.636},
  10: {10:0.730, 9.5:0.717, 9:0.705, 8.5:0.693, 8:0.681, 7.5:0.669, 7:0.658, 6.5:0.647, 6:0.636, 5.5:0.625, 5:0.614},
};

function rpeAdjusted1rm(weight, reps, rpe){
  if(!weight||!reps||!rpe) return null;
  const rpeVal=Math.round(parseFloat(rpe)*2)/2; // round to nearest 0.5
  const repRow=RPE_TABLE[Math.min(Math.max(Math.round(reps),1),10)];
  if(!repRow) return null;
  const pct=repRow[rpeVal];
  if(!pct) return null;
  return Math.round(weight/pct);
}

function calc1rm(weight, reps, rpe){
  // Prefer RPE-adjusted if RPE is available, fall back to Epley
  if(rpe&&parseFloat(rpe)>=5){
    const rpeResult=rpeAdjusted1rm(weight,reps,rpe);
    if(rpeResult) return {value:rpeResult, method:'rpe'};
  }
  const epleyResult=epley(weight,reps);
  return epleyResult?{value:epleyResult, method:'epley'}:null;
}

// ── BUILD METRICS DATA ────────────────────────────────────────────────────────
function buildMetrics(drillBlockId){
  const groups = { squat:{label:'Squat',variations:{}}, bench:{label:'Bench',variations:{}}, deadlift:{label:'Deadlift',variations:{}}, other:{label:'Other',variations:{}} };
  const blockIndex={};
  state.blocks.forEach((b,i)=>{ blockIndex[b.id]=i; });

  state.customLifts.forEach(cl=>{
    const g=groups[cl.group]||groups.other;
    if(!g.variations[cl.name]) g.variations[cl.name]=[];
  });

  // Raw weekly data — collect all points first
  const rawPoints=[]; // {blockId, blockName, weekLabel, exName, group, e1rm, method, topWeight, topReps}

  for(const [key,val] of Object.entries(state.logs)){
    const parts=key.split('||');
    if(parts.length<5) continue;
    const blockId=parts[0];
    const exName=parts[3];
    const weekLabel=parts[1];
    const setIdx=parts[4];
    if(!setIdx.startsWith('s')) continue;

    const setIdxNum=parseInt(setIdx.slice(1));
    let weight=null;
    if(val.actual){ weight=parseFloat(val.actual); }
    else if(val.done){ weight=getPrescribedWeight(parts[0],parts[1],parts[2],parts[3],setIdxNum); }
    if(!weight||isNaN(weight)||weight<=0) continue;

    const reps=getSetReps(parts[0],parts[1],parts[2],parts[3],setIdxNum);
    if(!reps) continue;

    const rpe=val.rpe?parseFloat(val.rpe):null;
    const result=calc1rm(weight,reps,rpe);
    if(!result) continue;

    const group=classifyLift(exName);
    if(!group) continue;
    if(!isTracked(exName)) continue;

    const block=state.blocks.find(b=>b.id===blockId);
    if(!block) continue;

    // Track best e1rm per exercise per week per block
    // Prefer RPE-based results over Epley estimates; tie-break by higher e1rm
    const existing=rawPoints.find(p=>p.blockId===blockId&&p.weekLabel===weekLabel&&p.exName===exName);
    if(existing){
      const newIsRpe=result.method==='rpe', oldIsRpe=existing.method==='rpe';
      if((newIsRpe&&!oldIsRpe)||(newIsRpe===oldIsRpe&&result.value>existing.e1rm)){
        existing.e1rm=result.value; existing.method=result.method; existing.topWeight=weight; existing.topReps=reps;
      }
    }
    else rawPoints.push({blockId,blockName:block.name,weekLabel,exName,group,e1rm:result.value,method:result.method,topWeight:weight,topReps:reps});
  }

  if(drillBlockId){
    // ── WEEKLY VIEW: show each week for the selected cycle ──────────────────
    const pts=rawPoints.filter(p=>p.blockId===drillBlockId);
    for(const pt of pts){
      const g=groups[pt.group]||groups.other;
      if(!g.variations[pt.exName]) g.variations[pt.exName]=[];
      g.variations[pt.exName].push({session:pt.weekLabel,blockId:pt.blockId,weekLabel:pt.weekLabel,e1rm:pt.e1rm,method:pt.method,topWeight:pt.topWeight,topReps:pt.topReps});
    }
    // Sort by week within cycle
    for(const g of Object.values(groups))
      for(const v of Object.values(g.variations))
        v.sort((a,b)=>sessionOrder(a.weekLabel)-sessionOrder(b.weekLabel));
  } else {
    // ── CYCLE VIEW: one point per cycle (best e1rm that cycle) ─────────────
    for(const pt of rawPoints){
      const g=groups[pt.group]||groups.other;
      if(!g.variations[pt.exName]) g.variations[pt.exName]=[];
      const existing=g.variations[pt.exName].find(p=>p.blockId===pt.blockId);
      if(existing){
        const newIsRpe=pt.method==='rpe', oldIsRpe=existing.method==='rpe';
        if((newIsRpe&&!oldIsRpe)||(newIsRpe===oldIsRpe&&pt.e1rm>existing.e1rm)){
          existing.e1rm=pt.e1rm; existing.method=pt.method; existing.topWeight=pt.topWeight; existing.topReps=pt.topReps; existing.bestWeek=pt.weekLabel;
        }
      }
      else g.variations[pt.exName].push({session:pt.blockName,blockId:pt.blockId,weekLabel:pt.weekLabel,e1rm:pt.e1rm,method:pt.method,topWeight:pt.topWeight,topReps:pt.topReps,bestWeek:pt.weekLabel,isCyclePoint:true});
    }
    // Sort by block index
    for(const g of Object.values(groups))
      for(const v of Object.values(g.variations))
        v.sort((a,b)=>(blockIndex[a.blockId]||0)-(blockIndex[b.blockId]||0));
  }

  return groups;
}

function sessionOrder(label){
  // Try to extract week number: "W1", "W2", "10 Weeks Out", "9 weeks out"
  const wm=label.match(/W(\d+)/i); if(wm) return parseInt(wm[1]);
  const nm=label.match(/(\d+)/); if(nm) return 1000-parseInt(nm[1]); // "10 weeks out" -> earlier = higher number
  return 999;
}

function getPrescribedWeight(blockId,weekLabel,dayName,exName,setIdx){
  // Returns numeric prescribed weight for a set, or null if RPE-based/unprescribed
  const block=state.blocks.find(b=>b.id===blockId);
  if(!block) return null;
  const week=block.weeks.find(w=>w.label===weekLabel);
  if(!week) return null;
  const day=week.days.find(d=>d.name===dayName);
  if(!day) return null;
  const ex=day.exercises.find(e=>e.name===exName);
  if(!ex||!ex.prescription) return null;
  const sets=parseSets(ex.prescription);
  const s=sets[setIdx];
  if(!s) return null;
  if(s.isRpe) return null; // RPE-based — can't assume weight
  const w=parseFloat(s.weight);
  return isNaN(w)?null:w;
}

function getSetReps(blockId,weekLabel,dayName,exName,setIdx){
  const block=state.blocks.find(b=>b.id===blockId);
  if(!block) return null;
  const week=block.weeks.find(w=>w.label===weekLabel);
  if(!week) return null;
  const day=week.days.find(d=>d.name===dayName);
  if(!day) return null;
  const ex=day.exercises.find(e=>e.name===exName);
  if(!ex||!ex.prescription) return null;

  const sets=parseSets(ex.prescription);
  if(sets[setIdx]) return sets[setIdx].reps;

  const simple=parseSimple(ex.prescription);
  if(simple){
    const r=String(simple.reps).split('-')[0];
    return parseInt(r)||null;
  }

  // Ranged prescription e.g. "3-4x15 (M)"
  const ranged=parseRangeSet(ex.prescription);
  if(ranged){
    const r=String(ranged.reps).split('-')[0];
    return parseInt(r)||null;
  }

  // Free-entry fallback — no reps prescribed, can't calculate 1RM
  return null;
}

// ── VARIATION COLORS ─────────────────────────────────────────────────────────
const VAR_COLORS = [
  '#C9A84C', // gold  — comp/primary
  '#a78bfa', // purple
  '#4ade80', // green
  '#f97316', // orange
  '#38bdf8', // blue
  '#f43f5e', // red
  '#e879f9', // pink
  '#2dd4bf', // teal
];

// ── METRICS RENDER ────────────────────────────────────────────────────────────
function renderMetrics(){
  const main=document.getElementById('main-content');
  const multiCycle=state.blocks.length>1;
  const activeBlockId=state.activeBlock?.id||state.blocks[state.blocks.length-1]?.id;

  // drill state: null = current cycle, 'all' = all cycles view
  const drill=state.metricsDrillBlock; // null | 'all' | specific blockId (legacy)

  // Determine which block to show data for
  // null drill = current cycle; 'all' = all blocks
  const drillBlockId = (drill && drill !== 'all') ? drill : (drill === 'all' ? null : activeBlockId);
  const metrics=buildMetrics(drillBlockId);
  let h=`<div class="metrics-screen">`;

  // No program loaded — empty state
  if(state.blocks.length===0){
    h+=`<div style="padding:16px">`;
    ['Squat','Bench','Deadlift'].forEach(label=>{
      h+=`<div class="metrics-lift-group" style="margin-bottom:16px">
        <div class="metrics-lift-header">
          <div class="metrics-lift-title">${label}</div>
          <div style="text-align:right"><div class="metrics-best" style="color:#2a2a2a">—</div><div class="metrics-best-label">Best Est. 1RM</div></div>
        </div>
        <div class="chart-wrap" style="position:relative">
          <canvas class="rm-chart" width="400" height="120" style="opacity:0.15"></canvas>
          <div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:12px;color:#333;letter-spacing:0.06em;text-transform:uppercase">No data</div>
        </div>
      </div>`;
    });
    h+=`<div style="text-align:center;font-size:13px;color:#444;padding:8px 0 24px">Load a program and log weights to start tracking</div>`;
    h+=`</div></div>`;
    main.innerHTML=h;
    return;
  }

  // Inline cycle toggle pills
  if(multiCycle){
    const activeBlock=state.blocks.find(b=>b.id===activeBlockId);
    const cycleName=activeBlock?activeBlock.name:'Current Cycle';
    const isCurrent=drill!=='all';
    h+=`<div class="metrics-cycle-toggle">
      <button class="metrics-toggle-pill${isCurrent?' active':''}" onclick="setMetricsDrill(null)">${cycleName}</button>
      <button class="metrics-toggle-pill${!isCurrent?' active':''}" onclick="setMetricsDrill('all')">All Cycles</button>
      <button class="metrics-export-btn" onclick="openExportModal('${esc(activeBlockId)}')" title="Export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></button>
    </div>`;
  }

  // Single cycle — show export button in its own header row
  if(!multiCycle && state.blocks.length > 0){
    h+=`<div class="metrics-cycle-toggle" style="justify-content:flex-end">
      <button class="metrics-export-btn" onclick="openExportModal('${esc(activeBlockId)}')" title="Export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></button>
    </div>`;
  }

  // ── Est. 1RM from logged comp lifts ──────────────────────────────────────
  const e1rmByGroup = { squat: null, bench: null, deadlift: null };
  const filterBlockId = drillBlockId; // null = all cycles, string = specific block
  for (const [key, val] of Object.entries(state.logs)) {
    const parts = key.split('||');
    if (parts.length < 5 || !parts[4].startsWith('s')) continue;
    if (filterBlockId && parts[0] !== filterBlockId) continue;
    const exName = parts[3];
    if (!isCompLift(exName)) continue;
    const group = classifyLift(exName);
    if (!group || group === 'other') continue;
    const si = parseInt(parts[4].slice(1));
    let weight = val.actual ? parseFloat(val.actual) : null;
    if (!weight || isNaN(weight) || weight <= 0) continue;
    const reps = getSetReps(parts[0], parts[1], parts[2], exName, si);
    if (!reps) continue;
    const rpe = val.rpe ? parseFloat(val.rpe) : null;
    const result = calc1rm(weight, reps, rpe);
    if (!result) continue;
    if (!e1rmByGroup[group] || result.value > e1rmByGroup[group]) e1rmByGroup[group] = Math.round(result.value);
  }
  if (e1rmByGroup.squat || e1rmByGroup.bench || e1rmByGroup.deadlift) {
    h += `<div class="maxes-bar">`;
    if (e1rmByGroup.squat) h += `<div class="max-item"><div class="max-lift">Squat</div><div class="max-weight">${e1rmByGroup.squat}</div><div style="font-size:9px;color:#555;letter-spacing:0.06em;text-transform:uppercase;margin-top:1px;">Est. 1RM</div></div>`;
    if (e1rmByGroup.bench) h += `<div class="max-item"><div class="max-lift">Bench</div><div class="max-weight">${e1rmByGroup.bench}</div><div style="font-size:9px;color:#555;letter-spacing:0.06em;text-transform:uppercase;margin-top:1px;">Est. 1RM</div></div>`;
    if (e1rmByGroup.deadlift) h += `<div class="max-item"><div class="max-lift">Dead</div><div class="max-weight">${e1rmByGroup.deadlift}</div><div style="font-size:9px;color:#555;letter-spacing:0.06em;text-transform:uppercase;margin-top:1px;">Est. 1RM</div></div>`;
    h += `</div>`;
  }

  let hasAnyData=false;
  for(const [groupKey,group] of Object.entries(metrics)){
    const vars=Object.entries(group.variations).filter(([,pts])=>pts.length>0);
    if(vars.length===0) continue;
    hasAnyData=true;

    const compVars=vars.filter(([vname])=>isCompLift(vname));
    const bestSource=compVars.length>0?compVars:vars;
    const best=Math.max(...bestSource.flatMap(([,pts])=>pts.map(p=>p.e1rm)));

    h+=`<div class="metrics-lift-group">`;
    h+=`<div class="metrics-lift-header">
      <div class="metrics-lift-title">${group.label}</div>
      <div style="text-align:right">
        <div class="metrics-best">${best?best+'lb':'-'}</div>
        <div class="metrics-best-label">Best Est. 1RM</div>
      </div>
    </div>`;

    h+=`<div class="var-legend">`;
    vars.forEach(([vname],vi)=>{
      const col=VAR_COLORS[vi%VAR_COLORS.length];
      h+=`<div class="legend-item"><span class="legend-dot" style="background:${col}"></span><span class="legend-label">${vname}</span></div>`;
    });
    h+=`</div>`;

    h+=`<div class="chart-wrap"><canvas class="rm-chart" id="chart-${esc(groupKey)}" width="400" height="160"></canvas></div>`;

    h+=`<div class="rm-datapoints">`;
    vars.forEach(([vname,pts],vi)=>{
      const col=VAR_COLORS[vi%VAR_COLORS.length];
      h+=`<div class="var-section">`;
      if(drill!=='all' && multiCycle && pts.length>0){
        h+=`<div class="var-section-title var-section-drill" onclick="setMetricsDrill('all')"><span class="legend-dot" style="background:${col}"></span>${vname}<span style="margin-left:auto;opacity:0.5;display:flex;align-items:center"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg></span></div>`;
      } else {
        h+=`<div class="var-section-title"><span class="legend-dot" style="background:${col}"></span>${vname}</div>`;
      }
      pts.forEach((pt,i)=>{
        const prev=pts[i-1];
        const delta=prev?pt.e1rm-prev.e1rm:null;
        const deltaStr=delta!==null?`<span class="rm-delta ${delta>=0?'up':'down'}">${delta>=0?'+':''}${delta}lb</span>`:'';
        const methodBadge=pt.method==='rpe'
          ?`<span class="method-badge rpe-badge">RPE</span>`
          :`<span class="method-badge est-badge">EST</span>`;
        const label=drill?pt.session:pt.session; // cycle name or week label
        const sublabel=drill
          ?(pt.topWeight&&pt.topReps?`${pt.topReps}×${pt.topWeight}lb`:'')
          :(pt.bestWeek?`Best: ${pt.bestWeek}`:'');
        h+=`<div class="rm-row">
          <div style="display:flex;flex-direction:column;gap:1px">
            <div class="rm-session">${label}</div>
            ${sublabel?`<div style="font-size:11px;color:#444">${sublabel}</div>`:''}
          </div>
          <div style="display:flex;align-items:center;gap:4px">${deltaStr}${methodBadge}<div class="rm-value" style="color:${col}">${pt.e1rm}lb</div></div>
        </div>`;
      });
      h+=`</div>`;
    });
    h+=`</div>`;
    h+=`</div>`;
  }

  if(!hasAnyData){
    h+=`<div class="no-data-msg">No performance data yet.<br><br>Log actual weights during your workouts and your estimated 1RMs will appear here.</div>`;
  }

  h+=`<button class="add-lift-btn" onclick="openAddLift()">+ Track Another Lift</button>`;
  h+=`</div>`;
  main.innerHTML=h;

  setTimeout(()=>{
    for(const [groupKey,group] of Object.entries(metrics)){
      const vars=Object.entries(group.variations).filter(([,pts])=>pts.length>0);
      if(vars.length===0) continue;
      drawOverlaidChart(`chart-${groupKey}`,vars,drillBlockId!==null);
    }
  },0);
}

function setMetricsDrill(val){ state.metricsDrillBlock=val; renderMetrics(); }

function drawOverlaidChart(canvasId, vars, drillMode){
  const canvas=document.getElementById(canvasId);
  if(!canvas) return;
  const ctx=canvas.getContext('2d');
  const W=canvas.offsetWidth||400;
  const H=160;
  canvas.width=W; canvas.height=H;

  const sessionOrderMap=new Map();
  vars.forEach(([,pts])=>pts.forEach(pt=>{ if(!sessionOrderMap.has(pt.session)) sessionOrderMap.set(pt.session, sessionOrderMap.size); }));
  const allSessions=[...new Set(vars.flatMap(([,pts])=>pts.map(p=>p.session)))]
    .sort((a,b)=>(sessionOrderMap.get(a)||0)-(sessionOrderMap.get(b)||0));
  if(allSessions.length===0) return;

  const allVals=vars.flatMap(([,pts])=>pts.map(p=>p.e1rm));
  const yMin=Math.min(...allVals)*0.95;
  const yMax=Math.max(...allVals)*1.05;
  const yRange=yMax-yMin||1;

  const pad={top:16,right:16,bottom:28,left:44};
  const chartW=W-pad.left-pad.right;
  const chartH=H-pad.top-pad.bottom;

  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle='#1e1e1e'; ctx.lineWidth=1;
  [0,0.5,1].forEach(t=>{
    const y=pad.top+chartH*(1-t);
    ctx.beginPath(); ctx.moveTo(pad.left,y); ctx.lineTo(W-pad.right,y); ctx.stroke();
    ctx.fillStyle='#444'; ctx.font='10px Barlow,sans-serif'; ctx.textAlign='right';
    ctx.fillText(Math.round(yMin+yRange*t)+'lb',pad.left-4,y+3);
  });

  function shortLabel(s){ const m=s.match(/W(\d+)$/i); return m?`W${m[1]}`:s.replace(/cycle\s*/i,'C'); }
  const step=allSessions.length>6?Math.ceil(allSessions.length/4):1;
  ctx.fillStyle='#444'; ctx.font='9px Barlow,sans-serif'; ctx.textAlign='center';
  allSessions.forEach((s,i)=>{
    if(i%step!==0&&i!==allSessions.length-1) return;
    const x=allSessions.length===1?pad.left+chartW/2:pad.left+(i/(allSessions.length-1))*chartW;
    ctx.fillText(shortLabel(s),x,H-6);
  });

  // Store dot positions for tap handling (cycle view only)
  const dotPositions=[];

  vars.forEach(([,pts],vi)=>{
    if(pts.length===0) return;
    const col=VAR_COLORS[vi%VAR_COLORS.length];
    const coords=pts.map(pt=>{
      const si=allSessions.indexOf(pt.session);
      const x=allSessions.length===1?pad.left+chartW/2:pad.left+(si/(allSessions.length-1))*chartW;
      const y=pad.top+chartH*(1-(pt.e1rm-yMin)/yRange);
      return{x,y,pt};
    });
    if(coords.length===1){
      ctx.fillStyle=col; ctx.beginPath(); ctx.arc(coords[0].x,coords[0].y,5,0,Math.PI*2); ctx.fill();
      if(!drillMode) dotPositions.push({x:coords[0].x,y:coords[0].y,r:10,blockId:coords[0].pt.blockId});
      return;
    }
    ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineJoin='round'; ctx.setLineDash([]);
    ctx.beginPath();
    coords.forEach((c,i)=>i===0?ctx.moveTo(c.x,c.y):ctx.lineTo(c.x,c.y));
    ctx.stroke();
    coords.forEach(c=>{
      ctx.fillStyle=col; ctx.beginPath(); ctx.arc(c.x,c.y,4,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#0a0a0a'; ctx.beginPath(); ctx.arc(c.x,c.y,2,0,Math.PI*2); ctx.fill();
      if(!drillMode) dotPositions.push({x:c.x,y:c.y,r:12,blockId:c.pt.blockId});
    });
  });

  // Tap to drill into a cycle (cycle view only)
  if(!drillMode&&dotPositions.length>0){
    canvas._drillHandler&&canvas.removeEventListener('click',canvas._drillHandler);
    canvas._drillHandler=(e)=>{
      const rect=canvas.getBoundingClientRect();
      const scaleX=canvas.width/rect.width;
      const scaleY=canvas.height/rect.height;
      const cx=(e.clientX-rect.left)*scaleX;
      const cy=(e.clientY-rect.top)*scaleY;
      for(const dot of dotPositions){
        if(Math.hypot(cx-dot.x,cy-dot.y)<dot.r){
          setMetricsDrill(dot.blockId);
          return;
        }
      }
    };
    canvas.addEventListener('click',canvas._drillHandler);
    // Show pointer cursor on hover
    canvas.style.cursor='pointer';
  } else {
    canvas.style.cursor='default';
  }
}

// ── ADD CUSTOM LIFT ───────────────────────────────────────────────────────────
let selectedGroup='squat';
function openAddLift(){ document.getElementById('add-lift-modal').style.display='flex'; document.getElementById('add-lift-name').value=''; }
function closeAddLift(){ document.getElementById('add-lift-modal').style.display='none'; }
function selectGroup(el){ selectedGroup=el.dataset.group; document.querySelectorAll('.group-pill').forEach(p=>p.classList.remove('active')); el.classList.add('active'); }
function confirmAddLift(){
  const name=document.getElementById('add-lift-name').value.trim();
  if(!name) return;
  if(!state.customLifts.find(c=>c.name.toLowerCase()===name.toLowerCase()))
    state.customLifts.push({name,group:selectedGroup});
  saveCustomLifts();
  closeAddLift();
  renderMetrics();
}

// ── EXERCISE NAME SPELLCHECK ─────────────────────────────────────────────────
const EXERCISE_DICT = [
  'Incline','Decline','Bench','Press','Squat','Deadlift','Row','Pull','Push',
  'Curl','Extension','Raise','Fly','Flye','Pulldown','Pullover','Pushdown',
  'Romanian','Reverse','Lateral','Front','Overhead','Close','Wide','Grip',
  'Barbell','Dumbbell','Cable','Machine','Smith','Hack','Leg','Hip',
  'Hamstring','Quadricep','Glute','Back','Chest','Shoulder','Tricep','Bicep',
  'Preacher','Spider','Concentration','Hammer','Pronated','Supinated','Neutral',
  'Prone','Supine','Standing','Seated','Lying','Bent','Straight','Single','Arm',
  'Unilateral','Bilateral','Compound','Isolation','Bulgarian','Split','Lunge',
  'Step','Box','Pause','Tempo','Deficit','Rack','Block','Pin','Board','Floor',
  'Sling','Shot','Larson','Larsen','Comp','Competition','Sumo','Conventional',
  'Stiff','Leg','Trap','Hex','Snatch','Clean','Jerk','Thruster','Turkish',
  'Get','Up','Swing','Windmill','Plank','Hold','Crunch','Situp','Sit',
  'Nautilus','Leverage','Preacher','Incline','Delt','Deltoid','Pec','Dec',
  'Crossover','Kickback','Skull','Crusher','Nose','Breaker','Tate','JM',
  'Zottman','Drag','Pinwheel','Reverse','Wrist','Forearm','Calf','Raise',
  'Nordic','Glute','Ham','Hyper','Extension','Good','Morning','Ab','Wheel',
  'Plank','Hollow','Body','Dragon','Flag','Hanging','Knee','Raise','Tuck',
  'Cuban','Arnold','Bradford','Landmine','Meadows','Pendlay','Yates','Kroc',
  'XPLoad','Rope','Band','Chain','Plate','Weight','Weighted','Bodyweight',
  'Dip','Chinup','Pullup','Pushup','Row','Inverted','Ring','TRX','Suspension',
];

function spellCorrectWord(word){
  // Skip short words, numbers, and already-correct words
  if(word.length<=3) return word;
  const lower=word.toLowerCase();
  // Check if it's in the dictionary (case-insensitive)
  const match=EXERCISE_DICT.find(d=>d.toLowerCase()===lower);
  if(match) return match; // normalize casing
  // Find closest match using edit distance
  let best=null; let bestDist=Infinity;
  for(const d of EXERCISE_DICT){
    const dist=editDistance(lower,d.toLowerCase());
    const threshold=word.length<=5?1:2; // stricter for short words
    if(dist<bestDist&&dist<=threshold){ bestDist=dist; best=d; }
  }
  return best||word;
}

function editDistance(a,b){
  const m=a.length,n=b.length;
  const dp=Array.from({length:m+1},(_,i)=>Array.from({length:n+1},(_,j)=>i===0?j:j===0?i:0));
  for(let i=1;i<=m;i++) for(let j=1;j<=n;j++)
    dp[i][j]=a[i-1]===b[j-1]?dp[i-1][j-1]:1+Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]);
  return dp[m][n];
}

function spellCorrectExerciseName(name){
  // Split on spaces, correct each word, rejoin
  return name.split(/\s+/).map(spellCorrectWord).join(' ');
}
const DAYS = ["monday","tuesday","wednesday","thursday","friday","saturday","sunday"];

function detectFormat(wb){
  try{
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rawRows = XLSX.utils.sheet_to_json(ws,{header:1,defval:null});
    const rows = rawRows.map(r=>r?r.map(c=>(typeof c==='string'&&c.startsWith("'"))?c.slice(1):c):r);
    for(let i=0;i<Math.min(10,rows.length);i++){
      const row=rows[i]; if(!row) continue;
      const hits=row.filter(c=>c&&DAYS.some(d=>String(c).toLowerCase().trim().startsWith(d)));
      if(hits.length>=2) return 'A';
    }
  }catch(e){ console.error('[liftlog] detectFormat error:',e); }
  return 'B';
}

// ── FORMAT A PARSER ───────────────────────────────────────────────────────────
function parseA(wb){
  const blocks=[];
  for(const sn of wb.SheetNames){
    try{
      const rows=XLSX.utils.sheet_to_json(wb.Sheets[sn],{header:1,defval:null});
      const clean=rows.map(r=>r?r.map(c=>{
        if(typeof c==='string'&&c.startsWith("'")) return c.slice(1);
        return c;
      }):r);
      const b=parseASheet(sn,clean);
      if(b) blocks.push(b);
    }catch(e){ console.error(`[parseA] Error parsing sheet "${sn}":`,e); }
  }
  return blocks;
}

function parseASheet(sn,rows){
  if(rows.length<4) return null;
  let hdr=-1;
  for(let i=0;i<Math.min(10,rows.length);i++){
    const r=rows[i]; if(!r) continue;
    if(r.filter(c=>c&&DAYS.some(d=>String(c).toLowerCase().trim().startsWith(d))).length>=2){hdr=i;break;}
  }
  if(hdr===-1) return null;

  const athleteName=rows[0]?.[0]?String(rows[0][0]).trim():'Athlete';
  // Use row 1 as name only if it looks like a cycle/program name, not a date range
  const row1val=rows[1]?.[0]?String(rows[1][0]).trim():'';
  const isDateLike=/^\d{1,2}[\/\-]/.test(row1val)||/\d{4}/.test(row1val);
  const name=(!isDateLike&&row1val)?row1val:sn;
  const dateRange=isDateLike?row1val:(rows[2]?.[0]?String(rows[2][0]).trim():'');
  let maxes={};
  for(let i=0;i<Math.min(5,rows.length);i++){
    const r=rows[i]; if(!r) continue;
    for(let j=0;j<r.length;j++){
      const c=String(r[j]||'').toLowerCase().trim();
      if(c==='squat'&&typeof rows[i+1]?.[j]==='number') maxes.squat=rows[i+1][j];
      if(c==='bench'&&typeof rows[i+1]?.[j]==='number') maxes.bench=rows[i+1][j];
      if(c==='deadlift'&&typeof rows[i+1]?.[j]==='number') maxes.deadlift=rows[i+1][j];
    }
  }
  const hrRow=rows[hdr];
  const dayCols=[];
  for(let col=0;col<hrRow.length;col++){
    const c=hrRow[col];
    if(c&&DAYS.some(d=>String(c).toLowerCase().trim().startsWith(d)))
      dayCols.push({col,name:String(c).trim(),noteCol:col+1});
  }
  const rawDays=dayCols.map(({col,name,noteCol})=>{
    const exs=[]; let cur=null; let curSupersetGroup=null;
    for(let r=hdr+1;r<rows.length;r++){
      const row=rows[r]; if(!row) continue;
      const cell=row[col]; const note=row[noteCol];
      // Blank row closes any open superset group
      if(cell===null||cell===undefined||!String(cell).trim()){ curSupersetGroup=null; continue; }
      const cs=String(cell).trim();
      const wm=cs.match(/^W(\d+):\s*(.+)/i);
      if(wm){ if(cur){ const wNote=note?String(note).trim():null; cur.weeks.push({week:parseInt(wm[1]),prescription:wm[2].trim(),note:wNote}); } }
      else{
        // Prescription patterns:
        // lp = has parens with digits or RPE letters: 3x5(275), 12(L), 1 rep (rest :10)
        // lp2 = NxN format without parens: 4x15, 3x5, 4x12
        const lp=(/\(/.test(cs)&&(/\d/.test(cs)||/[LMH]/.test(cs)));
        const lp2=/^\d+x\d+/i.test(cs); // e.g. "4x15", "3x5"
        const ln=cs.startsWith('(')||cs.toLowerCase().includes('increase');
        const supersetMatch=
          cs.match(/^(\d+)\s*rounds?[\s:]*/i) ||  // "2 rounds:"
          (cs.match(/^superset[\s:]*/i) && ['1']) ||
          (cs.match(/^SS[\s:]*/i) && ['1']) ||
          (cs.match(/^giant\s*set[\s:]*/i) && ['1']) ||
          (cs.match(/^circuit[\s:]*/i) && ['1']);
        const isSectionHeader=
          supersetMatch!=null ||
          /^round\s*\d/i.test(cs) ||            // "Round 1"
          /^\d+\s*rep\s/i.test(cs) ||          // "1 rep (rest :10)"
          /^\d+\.?\d*\s*$/.test(cs);           // bare number like "2.0"
        // Coach note patterns:
        // - wrapped in dashes: -McGill Protocol-
        // - starts with "goal", "continue", "protocol"
        // - is a sentence (contains space, ends with period or has >4 words) but is NOT a known exercise format
        const wordCount=cs.split(/\s+/).length;
        const isCoachNoteLine=
          /^-.*-$/.test(cs) ||
          /^goal\b/i.test(cs) ||
          /^continue\b/i.test(cs) ||
          /^protocol\b/i.test(cs) ||
          (cs.endsWith('.')&&wordCount>=4&&!lp&&!lp2&&!ln);

        // Superset group tracking: open on header, close on blank row
        if(supersetMatch){
          const rounds=parseInt(supersetMatch[1])||1;
          const label=rounds>1?rounds+' rounds':'superset';
          curSupersetGroup={label,rounds,startIdx:exs.length};
        }

        if(!lp&&!lp2&&!ln&&!isSectionHeader&&!isCoachNoteLine){
          let normalizedCs=cs.replace(/\s+/g,' ').trim(); // collapse double spaces
          // Detect "20 Reverse Hyper" pattern — leading number is a rep count, not part of name
          let embeddedPres=null;
          const leadingRepsMatch=normalizedCs.match(/^(\d+(?:[:\.]\d+)?)\s+([A-Za-z].+)$/);
          if(leadingRepsMatch){
            embeddedPres=leadingRepsMatch[1]; // e.g. "20" or "1:00"
            normalizedCs=leadingRepsMatch[2]; // e.g. "Reverse Hyper" or "Plank Hold"
          }
          const correctedName=spellCorrectExerciseName(normalizedCs);
          cur={name:correctedName,weeks:[],staticPrescription:embeddedPres||null,note:note?String(note).trim():null,coachNotes:[],supersetGroup:curSupersetGroup||null};
          exs.push(cur);
        } else if(cur&&(isCoachNoteLine||ln)){
          const noteText=cs.replace(/^-|-$/g,'').trim();
          if(noteText&&!cur.coachNotes.includes(noteText)) cur.coachNotes.push(noteText);
        } else if(cur&&(lp||lp2)&&!cur.staticPrescription){
          cur.staticPrescription=cs;
          if(note) cur.note=String(note).trim();
        }
      }
    }
    return{name,exercises:exs};
  });

  let nw=0;
  for(const d of rawDays) for(const e of d.exercises) if(e.weeks.length>nw) nw=e.weeks.length;
  if(nw===0) nw=4;

  const weeks=[];
  for(let w=1;w<=nw;w++){
    weeks.push({label:`W${w}`,days:rawDays.map(d=>({name:d.name,exercises:d.exercises.map(ex=>{
      const wd=ex.weeks.find(x=>x.week===w);
      return{name:ex.name,prescription:wd?.prescription||ex.staticPrescription||null,note:wd?.note||ex.note||null,coachNotes:ex.coachNotes||[],supersetGroup:ex.supersetGroup||null};
    })}))});
  }

  return{id:sn,name,dateRange,athleteName,maxes,weeks,format:'A'};
}

// ── FORMAT B PARSER ───────────────────────────────────────────────────────────
function parseB(wb){
  const weeks=[];
  let athleteName='Athlete';
  for(const sn of wb.SheetNames){
    try{
      const rows=XLSX.utils.sheet_to_json(wb.Sheets[sn],{header:1,defval:null});
      const week=parseBSheet(sn,rows);
      if(week) weeks.push(week);
    }catch(e){ console.error(`[parseB] Error parsing sheet "${sn}":`,e); }
  }
  if(weeks.length===0) return [];
  const blocks=[{id:'program',name:'Training Program',dateRange:'',athleteName,maxes:{},weeks,format:'B'}];
  return blocks;
}

function parseBSheet(sn,rows){
  if(!rows||rows.length===0) return null;
  const days=[]; let curDay=null;

  // Column indices can shift between sheets — detect from header row per day section
  // We track the current header columns dynamically
  let colPres=1, colLogged=2; // defaults

  for(let i=0;i<rows.length;i++){
    const row=rows[i]; if(!row) continue;
    const a=row[0]; if(!a) continue;
    const aStr=String(a).trim(); if(!aStr) continue;
    if(/^\d+\.?\d*\s*$/.test(aStr)) continue; // skip bare numbers (integers and decimals like 2.0)

    // A day section header has:
    // 1. A short name in col 0 (day section names are typically < 20 chars)
    // 2. The word "sets" or "record" in the row (not just "reps" which appears in prescriptions)
    const rowStrs=row.map(c=>String(c||'').toLowerCase());
    const hasSetsHeader=rowStrs.some(s=>s.includes('sets x') || s.includes('sets/') || (s.includes('sets') && s.includes('rpe')));
    const hasRecordHeader=rowStrs.some(s=>s.includes('record weight') || s.includes('record'));
    const isDayHeader=(hasSetsHeader||hasRecordHeader) && aStr.length < 25;

    if(isDayHeader){
      // Detect column positions from this header row
      const prescIdx=rowStrs.findIndex(s=>s.includes('sets'));
      const loggedIdx=rowStrs.findIndex(s=>s.includes('record')||s.includes('weight'));
      if(prescIdx>0) colPres=prescIdx;
      if(loggedIdx>colPres) colLogged=loggedIdx;
      else colLogged=colPres+1; // fallback: logged is always right after prescription
      curDay={name:aStr,exercises:[]}; days.push(curDay);
    } else if(curDay){
      const pres=row[colPres]!=null?String(row[colPres]).trim():null;
      const rawLogged=row[colLogged];

      // Logged can be a number (e.g. 90.0) or string (e.g. "165@6", "Seal row 55lbs + bar")
      let cleanLogged=null;
      if(rawLogged!=null){
        const ls=String(rawLogged).trim();
        // Skip if it's only checkmarks/whitespace
        if(ls&&!/^[✔️\s]+$/.test(ls)) cleanLogged=ls;
      }

      // Coach note: look for non-checkmark text in remaining columns
      let note=null;
      for(let c=colLogged+1;c<row.length;c++){
        const v=row[c];
        if(v==null) continue;
        const vs=String(v).trim();
        if(vs&&!/^[✔️\s]+$/.test(vs)){ note=vs; break; }
      }

      const normName=aStr.replace(/\s+/g,' ').trim(); // collapse double spaces
      curDay.exercises.push({name:normName,prescription:pres,note,loggedWeight:cleanLogged});
    }
  }
  if(days.length===0) return null;
  return{label:sn,days};
}

// ── UNIFIED ───────────────────────────────────────────────────────────────────
function parseWorkbook(wb){
  return detectFormat(wb)==='A' ? parseA(wb) : parseB(wb);
}

// ── BLOCK MERGE ───────────────────────────────────────────────────────────────
function mergeBlocks(incoming){
  const existing=state.blocks;
  for(const inc of incoming){
    const idx=existing.findIndex(b=>b.id===inc.id);
    if(idx!==-1){ existing[idx]=inc; } // replace structure, logs survive (keyed separately)
    else { existing.push(inc); }
  }
  state.blocks=existing;
  state.activeBlock=incoming[incoming.length-1]||state.activeBlock;
}

// ── SET PARSER ────────────────────────────────────────────────────────────────
function parseSets(pres){
  if(!pres) return [];
  const sets=[]; const pat=/(\d+x)?(\d+)\(([^)]+)\)/g; let m;
  while((m=pat.exec(pres))!==null){
    const mult=m[1]?parseInt(m[1]):1;
    for(let i=0;i<mult;i++) sets.push({reps:parseInt(m[2]),weight:m[3].trim(),isRpe:isNaN(Number(m[3].trim()))});
  }
  return sets;
}
function parseSimple(pres){
  if(!pres) return null;
  const m=pres.match(/^(\d+)x([\d\-]+)/i);
  if(!m) return null;
  // Exclude range-set patterns like "3-4x15" — those go to parseRangeSet
  if(pres.match(/^\d+[\-–]\d+x/i)) return null;
  return{sets:parseInt(m[1]),reps:m[2]};
}
// Handles "3-4x15 (M)", "3x12-15", range-set patterns with no specific weight
function parseRangeSet(pres){
  if(!pres) return null;
  // Standard: "3x10", "3-4x10", "3x8-12"
  const m=pres.match(/^(\d+)[\-–]?(\d*)x([\d\-]+)/i);
  if(m){
    const sets=parseInt(m[1]); // use lower bound of set range
    const reps=m[3];
    return{sets,reps};
  }
  // "2-3 sets" or "2-3 sets (pick reps)" — sets range, open reps
  const s=pres.match(/^(\d+)[\-–](\d+)\s*sets?/i);
  if(s) return{sets:parseInt(s[1]),reps:'open'};
  return null;
}

// Handles bare prescriptions like "20" (reps) or "1:00" (time) — single set, no weight in prescription
function parseBarePres(pres){
  if(!pres) return null;
  const p=pres.trim();
  // bare number: "20"
  if(/^\d+$/.test(p)) return{sets:1,reps:p};
  // time format: "1:00", "0:30"
  if(/^\d+:\d{2}$/.test(p)) return{sets:1,reps:p};
  return null;
}

// ── RENDER ────────────────────────────────────────────────────────────────────
function render(){
  if(state.screen==='metrics'){ renderMetrics(); return; }
  if(state.screen==='calc'){ renderCalc(); return; }
  renderWorkout();
}

// ── renderWorkout sub-functions ───────────────────────────────────────────────

function renderUploadScreen() {
  return `<div class="upload-screen">
    <div class="upload-icon"><svg viewBox="0 0 28 40" fill="#C9A84C" width="32" height="48"><polygon points="18,0 7,22 14,22 10,40 21,18 14,18"/></svg></div>
    <div class="upload-title">Load Your Program</div>
    <div class="upload-desc">Upload the Excel file your coach sent you. Your workouts will be formatted for mobile.</div>
    <button class="upload-btn" onclick="document.getElementById('file-input').click()" style="display:flex;align-items:center;justify-content:center;gap:9px">UPLOAD FROM DEVICE<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" width="18" height="18"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></button>
    <div class="upload-divider"><span>or</span></div>
    <button class="drive-btn" onclick="openDrivePicker()" style="display:flex;align-items:center;justify-content:center;gap:9px">UPLOAD FROM DRIVE<img src="https://www.gstatic.com/images/branding/product/1x/drive_2020q4_32dp.png" style="width:20px;height:20px"></button>
  </div>`;
}

function renderBlockBar(block) {
  if(state.editingBlockName){
    return `<div class="block-bar">
      <input class="block-name-edit" id="block-name-input" value="${esc(block.name)}"
        onblur="saveBlockName()"
        onkeydown="if(event.key==='Enter')this.blur();if(event.key==='Escape'){state.editingBlockName=false;render();}">
      <div class="block-dates">${block.dateRange}</div>
    </div>`;
  }
  let h=`<div class="block-bar"><div style="display:flex;align-items:center;gap:6px">
    <div><div class="block-name">${block.name}</div><div class="block-dates">${block.dateRange}</div></div>
    <button class="edit-name-btn" style="opacity:0.3;font-size:11px" onclick="state.editingBlockName=true;render();setTimeout(()=>{const el=document.getElementById('block-name-input');if(el){el.focus();el.select();}},50)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>
  </div>`;
  if(state.blocks.length>1){
    h+=`<select class="cycle-select" onchange="switchBlock(this.value)">`;
    state.blocks.forEach(b=>h+=`<option value="${b.id}" ${b.id===block.id?'selected':''}>${b.id}</option>`);
    h+=`</select>`;
  }
  h+=`</div>`;
  return h;
}

function renderWeekPills(block) {
  let h=`<div class="week-bar">`;
  block.weeks.forEach((w,wi)=>{
    const weekDone=w.days.every(d=>isDayComplete(block,w,d));
    const dot=weekDone?' <span style="font-size:13px;color:#4ade80">✓</span>':'';
    h+=`<button class="week-pill ${state.activeWeek===wi?'active':''}" onclick="setWeek(${wi})">${w.label}${dot}</button>`;
  });
  h+=`</div>`;
  return h;
}

function renderDayTabs(block, week) {
  if(!week?.days?.length) return '';
  let h=`<div class="day-tabs">`;
  week.days.forEach((d,di)=>{
    const complete=isDayComplete(block,week,d);
    h+=`<button class="day-tab ${state.activeDay===di?'active':''}" onclick="setDay(${di})">${d.name}${complete?'<span class="done-dot">✓</span>':''}</button>`;
  });
  h+=`</div>`;
  return h;
}

function renderNextWorkoutBanner(block) {
  const _next=findNextWorkout(block);
  if(_next.weekIdx===state.activeWeek && _next.dayIdx===state.activeDay) return '';
  const nw=block.weeks[_next.weekIdx]; const nd=nw?.days[_next.dayIdx];
  if(!nd) return '';
  return `<div class="next-workout-banner" onclick="state.activeWeek=${_next.weekIdx};state.activeDay=${_next.dayIdx};state.expandedEx=new Set();saveNav();render()">
    <span class="next-workout-banner-text"><svg viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg> Next workout: ${nw.label} — ${nd.name}</span><span class="next-workout-banner-arrow">→</span>
  </div>`;
}

function renderProgressBar(pct) {
  return `<div class="progress-wrap"><div class="progress-bg"><div class="progress-fill" style="width:${pct}%"></div></div></div>`;
}

function renderExCard(ex, groupKeys, block, week, day) {
  let h = '';
  const key=lk(block.id,week.label,day.name,ex.name);
  const log=state.logs[key]||{};
  const isDone=log.done||false;
  const isSkipped=log.skipped||false;
  const pres=ex.prescription;
  const sets=pres?parseSets(pres):[];
  const hasSets=sets.length>0;
  const simple=parseSimple(pres);
  const ranged=(!hasSets&&!simple)?parseRangeSet(pres):null;
  const supersetRounds = ex.supersetGroup?.rounds || 1;
  const bare=(!hasSets&&!simple&&!ranged)?parseBarePres(pres):null;
  const bareWithRounds = bare ? {...bare, sets: supersetRounds} : null;
  const inputMode=getExerciseInputMode(ex.name,pres);

  const isComp=isCompLift(ex.name);
  const group=classifyLift(ex.name);
  const tracked=isTracked(ex.name);
  const showTrackBtn=group!==null;

  const trackBtn=showTrackBtn
    ?`<button class="track-btn ${tracked?'tracked':''} ${isComp?'is-comp':''}" onclick="toggleTracked('${esc(ex.name)}',event)" title="${tracked?'Remove from metrics':'Track in metrics'}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></button>`
    :'';

  function presShortSummary(sets,simple,ranged,pres){
    if(sets.length>0){
      const firstWeight=sets[0].isRpe?`@ ${sets[0].weight}`:`@ ${sets[0].weight}lb`;
      const allSame=sets.every(s=>s.reps===sets[0].reps&&s.weight===sets[0].weight);
      if(allSame) return `${sets.length}×${sets[0].reps} ${firstWeight}`;
      return sets.map(s=>s.isRpe?`${s.reps}@${s.weight}`:`${s.reps}@${s.weight}lb`).join(' · ');
    }
    if(simple) return `${simple.sets}×${simple.reps}`;
    if(ranged) return `${ranged.sets}×${ranged.reps}`;
    if(bareWithRounds) return `${bareWithRounds.sets>1?bareWithRounds.sets+'×':''}${bareWithRounds.reps}`;
    if(pres) return pres;
    return '';
  }

  function setInputsHtml(sk,sl,placeholder){
    if(placeholder==='open') return `<div class="set-inputs-wrap">
              <div class="set-input-group"><div class="set-input-label">Reps</div>
                <input class="set-input" inputmode="decimal" placeholder="reps" value="${sl.actual||''}" oninput="setActual('${esc(sk)}',this.value)">
              </div>
            </div>`;
    if(inputMode==='bw'||inputMode==='cardio') return '';
    if(inputMode==='bw-timed') return `<div class="set-inputs-wrap">
              <div class="set-input-group"><div class="set-input-label">Reps</div>
                <input class="set-input" inputmode="decimal" placeholder="reps" value="${sl.actual||''}" oninput="setActual('${esc(sk)}',this.value)">
              </div>
            </div>`;
    return `<div class="set-inputs-wrap">
              <div class="set-input-group"><div class="set-input-label">Weight</div>
                <input class="set-input" inputmode="decimal" placeholder="${placeholder}" value="${sl.actual||''}" oninput="setActual('${esc(sk)}',this.value)">
              </div>
              <div class="set-input-group"><div class="set-input-label">RPE felt</div>
                <input class="set-input rpe-input" inputmode="decimal" placeholder="1–10" value="${sl.rpe||''}" oninput="setRpe('${esc(sk)}',this.value)">
              </div>
            </div>`;
  }

  const isExpanded=state.expandedEx.has(key);
  const presSum=presShortSummary(sets,simple,ranged,pres);
  const setsCompletedCount=[...Array(sets.length||(simple?.sets||0)||(ranged?.sets||0)||(bareWithRounds?.sets||0)||(pres?1:0))].filter((_,si)=>(state.logs[key+`||s${si}`]||{}).done).length;
  const totalSetsCount=sets.length||(simple?.sets||0)||(ranged?.sets||0)||(bare?.sets||0)||(pres?1:0);

  h+=`<div class="exercise-card ${isDone?'completed':isSkipped?'skipped':''}">`;

  h+=`<div class="ex-summary" onclick="toggleExpand('${esc(key)}','${groupKeys?esc(groupKeys.join(':::')):''}')">
    <div class="ex-summary-left">
      <div class="ex-summary-name ${isDone?'done':isSkipped?'skipped':''}">${ex.name}</div>
      ${presSum?`<div class="ex-summary-pres">${presSum}${totalSetsCount>0?' · '+setsCompletedCount+'/'+totalSetsCount+' sets':''}</div>`:''}
    </div>
    <div class="ex-summary-right">
      ${showTrackBtn && !tracked ? `<button class="track-btn ${isComp?'is-comp':''}" onclick="toggleTracked('${esc(ex.name)}',event)" title="Track in metrics"><span class="track-hint-inline">Track</span><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></button>` : trackBtn}
      ${isSkipped ? `<span class="skipped-badge">SKIPPED</span>` : ''}
      <button class="exercise-check ${isDone?'done':''}" onclick="event.stopPropagation();toggleEx('${esc(key)}')">${isDone?'✓':''}</button>
      <span class="ex-expand-icon ${isExpanded?'open':''}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg></span>
    </div>
  </div>`;

  if(isExpanded){
    h+=`<div class="ex-detail">`;

    const editingThis=state.editingExKey===key;
    if(editingThis){
      h+=`<div class="exercise-header" style="padding:10px 16px 4px">
        <input class="exercise-name-edit" id="ex-edit-${esc(key)}" value="${ex.name.trim()}"
          onblur="saveExName('${esc(key)}','${esc(ex.name)}')"
          onkeydown="if(event.key==='Enter')this.blur();if(event.key==='Escape'){state.editingExKey=null;render();}">
      </div>`;
    } else {
      h+=`<div style="display:flex;align-items:center;gap:6px;padding:10px 16px 4px">
        <button class="edit-name-btn" style="opacity:0.4" onclick="startEditEx('${esc(key)}')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg> Edit name</button>
      </div>`;
    }
    

    if(hasSets){
      h+=`<div class="sets-grid">`;
      sets.forEach((s,si)=>{
        const sk=key+`||s${si}`; const sl=state.logs[sk]||{};
        h+=`<div class="set-row">
          <div class="set-num">S${si+1}</div>
          <div class="set-prescribed">${s.isRpe ? s.reps+' '+s.weight : s.weight+'×'+s.reps}</div>
          ${setInputsHtml(sk,sl,s.isRpe?'lbs':s.weight+'lb')}
          <button class="set-check ${sl.done?'done':''}" onclick="toggleSet('${esc(sk)}')">${sl.done?'✓':''}</button>
        </div>`;
      });

      // Extra sets (+ Set button) — weighted style
      const _extra=state.extraSets[key]||0;
      if(_extra>0){
        const _lastS=sets[sets.length-1]||{};
        for(let _i=0;_i<_extra;_i++){
          const _si=sets.length+_i; const _sk=key+`||s${_si}`; const _sl=state.logs[_sk]||{};
          h+=`<div class="set-row">
            <div class="set-num">S${_si+1}</div>
            <div class="set-prescribed">${_lastS.isRpe ? (_lastS.reps||'—')+' '+(_lastS.weight||'') : (_lastS.weight||'—')+'×'+(_lastS.reps||'—')}</div>
            ${setInputsHtml(_sk,_sl,_lastS.isRpe?'lbs':(_lastS.weight?_lastS.weight+'lb':'lbs'))}
            <button class="set-check ${_sl.done?'done':''}" onclick="toggleSet('${esc(_sk)}')">${_sl.done?'✓':''}</button>
          </div>`;
        }
      }
      h+=`</div>`;
    } else if(pres&&simple){
      h+=`<div class="prescription purple">${pres}</div><div class="sets-grid">`;
      for(let si=0;si<simple.sets;si++){
        const sk=key+`||s${si}`; const sl=state.logs[sk]||{};
        h+=`<div class="set-row">
          <div class="set-num">S${si+1}</div><div class="set-prescribed">${simple.reps} reps</div>
          ${setInputsHtml(sk,sl,'lbs')}
          <button class="set-check ${sl.done?'done':''}" onclick="toggleSet('${esc(sk)}')">${sl.done?'✓':''}</button>
        </div>`;
      }

      // Extra sets — simple style
      const _extra=state.extraSets[key]||0;
      if(_extra>0){
        for(let _i=0;_i<_extra;_i++){
          const _si=simple.sets+_i; const _sk=key+`||s${_si}`; const _sl=state.logs[_sk]||{};
          h+=`<div class="set-row">
            <div class="set-num">S${_si+1}</div><div class="set-prescribed">${simple.reps} reps</div>
            ${setInputsHtml(_sk,_sl,'lbs')}
            <button class="set-check ${_sl.done?'done':''}" onclick="toggleSet('${esc(_sk)}')">${_sl.done?'✓':''}</button>
          </div>`;
        }
      }
      h+=`</div>`;
    } else if(pres&&ranged){
      h+=`<div class="prescription purple">${pres}</div><div class="sets-grid">`;
      for(let si=0;si<ranged.sets;si++){
        const sk=key+`||s${si}`; const sl=state.logs[sk]||{};
        const isOpen=ranged.reps==='open';
        h+=`<div class="set-row">
          <div class="set-num">S${si+1}</div>${isOpen?'':'<div class="set-prescribed">'+ranged.reps+' reps</div>'}
          ${setInputsHtml(sk,sl,isOpen?'open':'lbs')}
          <button class="set-check ${sl.done?'done':''}" onclick="toggleSet('${esc(sk)}')">${sl.done?'✓':''}</button>
        </div>`;
      }

      // Extra sets — ranged style
      const _extra=state.extraSets[key]||0;
      if(_extra>0){
        const _isOpen=ranged.reps==='open';
        for(let _i=0;_i<_extra;_i++){
          const _si=ranged.sets+_i; const _sk=key+`||s${_si}`; const _sl=state.logs[_sk]||{};
          h+=`<div class="set-row">
            <div class="set-num">S${_si+1}</div>${_isOpen?'':'<div class="set-prescribed">'+ranged.reps+' reps</div>'}
            ${setInputsHtml(_sk,_sl,_isOpen?'open':'lbs')}
            <button class="set-check ${_sl.done?'done':''}" onclick="toggleSet('${esc(_sk)}')">${_sl.done?'✓':''}</button>
          </div>`;
        }
      }
      h+=`</div>`;
    } else if(bareWithRounds){
      h+=`<div class="sets-grid">`;
      for(let si=0;si<bareWithRounds.sets;si++){
        const sk=key+`||s${si}`; const sl=state.logs[sk]||{};
        h+=`<div class="set-row">
          <div class="set-num">S${si+1}</div><div class="set-prescribed">${bareWithRounds.reps} reps</div>
          ${setInputsHtml(sk,sl,'lbs')}
          <button class="set-check ${sl.done?'done':''}" onclick="toggleSet('${esc(sk)}')">${sl.done?'✓':''}</button>
        </div>`;
      }

      // Extra sets — bare style
      const _extra=state.extraSets[key]||0;
      if(_extra>0){
        for(let _i=0;_i<_extra;_i++){
          const _si=bareWithRounds.sets+_i; const _sk=key+`||s${_si}`; const _sl=state.logs[_sk]||{};
          h+=`<div class="set-row">
            <div class="set-num">S${_si+1}</div><div class="set-prescribed">${bareWithRounds.reps} reps</div>
            ${setInputsHtml(_sk,_sl,'lbs')}
            <button class="set-check ${_sl.done?'done':''}" onclick="toggleSet('${esc(_sk)}')">${_sl.done?'✓':''}</button>
          </div>`;
        }
      }
      h+=`</div>`;
    } else if(pres){
      const sk=key+`||s0`; const sl=state.logs[sk]||{};
      h+=`<div class="prescription purple">${pres}</div><div class="sets-grid">`;
      h+=`<div class="set-row">
        <div class="set-num">S1</div><div class="set-prescribed">open</div>
        ${setInputsHtml(sk,sl,'lbs')}
        <button class="set-check ${sl.done?'done':''}" onclick="toggleSet('${esc(sk)}')">${sl.done?'✓':''}</button>
      </div>`;
      h+=`</div>`;
    }

    const prevPerf=getPrevWeekPerformance(block.id,week.label,day.name,ex.name);
    if(prevPerf){
      const srcLabel=prevPerf.source
        ?`Last performed (${prevPerf.source} — ${prevPerf.label})`
        :`Last time (${prevPerf.label})`;
      h+=`<div class="prev-performance">
        <div class="prev-performance-label">${srcLabel}</div>
        <div class="prev-performance-sets">
          ${prevPerf.sets.map((s,i)=>`<span class="prev-performance-set">S${i+1}: ${s.actual}${s.rpe?' @'+s.rpe:''}</span>`).join('')}
        </div>
      </div>`;
    }

    const allCoachNotes=[...(ex.coachNotes||[])];
    if(ex.note&&!allCoachNotes.includes(ex.note)) allCoachNotes.unshift(ex.note);
    if(allCoachNotes.length>0){
      h+=`<div class="notes-section">
        <div class="notes-label"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg> Coach Notes</div>
        ${allCoachNotes.map(n=>`<div class="coach-note">${n}</div>`).join('')}
      </div>`;
    }

    const prevNote=getPrevWeekNote(block.id,week.label,day.name,ex.name);
    h+=`<div class="notes-section">
      <div class="notes-label"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg> My Notes</div>
      ${prevNote?`<div class="lifter-prev-note">Last time: "${prevNote}"</div>`:''}
      <div class="notes-area"><textarea class="notes-input" placeholder="Add a note for next time..." oninput="setNote('${esc(key)}',this.value)">${log.notes||''}</textarea></div>
    </div>`;
    h+=`</div>`; // ex-detail - close notes section
    h+=`<div class="skip-row">
      <button class="set-adjust-btn" onclick="adjustSets('${esc(key)}',-1)">− Set</button>
      <button class="set-adjust-btn" onclick="adjustSets('${esc(key)}',1)">+ Set</button>
      <button class="skip-btn ${isSkipped?'active':''}" onclick="toggleSkip('${esc(key)}')">${isSkipped?'↩ Undo Skip':'Skip Exercise'}</button>
    </div>`;
  }

  h+=`</div>`; // exercise-card
  return h;
}

function renderExerciseList(block, week, day) {
  if(!day || day.exercises.length===0){
    return `<div class="rest-msg">Rest day. Eat enough protein.</div>`;
  }

  const renderItems = [];
  let i = 0;
  while (i < day.exercises.length) {
    const ex = day.exercises[i];
    if (ex.supersetGroup) {
      const groupLabel = ex.supersetGroup.label;
      const cluster = [];
      while (i < day.exercises.length && day.exercises[i].supersetGroup && day.exercises[i].supersetGroup.label === groupLabel) {
        cluster.push(day.exercises[i]);
        i++;
      }
      renderItems.push({ type: 'superset', label: groupLabel, exercises: cluster });
    } else {
      renderItems.push({ type: 'single', ex });
      i++;
    }
  }

  let h = '';
  renderItems.forEach(item => {
    if (item.type === 'single') {
      h += renderExCard(item.ex, null, block, week, day);
    } else {
      const groupKeys = item.exercises.map(ex => lk(block.id, week.label, day.name, ex.name));
      h += `<div class="superset-group">`;
      h += `<div class="superset-header" onclick="toggleExpand('${esc(groupKeys[0])}','${esc(groupKeys.join(':::'))}')" style="cursor:pointer"><span class="superset-badge">${item.label}</span><span class="superset-label">${item.exercises.map(e=>e.name).join(" · ")}</span></div>`;
      item.exercises.forEach(ex => { h += renderExCard(ex, groupKeys, block, week, day); });
      h += `</div>`;
    }
  });

  const dayComplete=isDayComplete(block,week,day);
  if(!dayComplete){
    h+=`<button class="complete-workout-btn" onclick="completeWorkout()">✓ Complete Workout</button>`;
  } else {
    h+=`<div class="workout-complete-msg">✓ Workout Complete <button class="clear-workout-btn" onclick="clearWorkout()" title="Clear workout"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6M14 11v6"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg></button></div>`;
  }

  return h;
}

// ── Main orchestrator ─────────────────────────────────────────────────────────
function renderWorkout(){
  const main=document.getElementById('main-content');
  document.getElementById('athlete-name').textContent=state.activeBlock?.athleteName||'';
  document.getElementById('new-btn').textContent=state.blocks.length===0?'Load Program':'Manage Programs';

  if(!state.activeBlock){ main.innerHTML=renderUploadScreen(); return; }

  const block=state.activeBlock;
  const week=block.weeks[state.activeWeek];
  const day=week?.days[state.activeDay];
  const total=day?.exercises.length||0;
  const done=total>0?day.exercises.filter(ex=>{ const l=state.logs[lk(block.id,week.label,day.name,ex.name)]||{}; return l.done||l.skipped; }).length:0;
  const pct=total>0?Math.round(done/total*100):0;

  let h='';
  h+=renderBlockBar(block);
  h+=renderWeekPills(block);
  h+=renderDayTabs(block, week);
  h+=renderNextWorkoutBanner(block);
    h+=`<div class="exercises">`;
  h+=renderExerciseList(block, week, day);
  h+=`</div>`;
  main.innerHTML=h;
}

function abbrev(name){
  const n=name.trim();
  const m=n.match(/^(upper|lower|push|pull|squat|bench|dead)\s*(\d*)/i);
  if(m){
    const map={upper:'UPR',lower:'LWR',push:'PSH',pull:'PUL',squat:'SQT',bench:'BCH',dead:'DL'};
    return (map[m[1].toLowerCase()]||m[1].substring(0,3).toUpperCase())+(m[2]?' '+m[2]:'');
  }
  return n.substring(0,3).toUpperCase();
}

function saveBlockName(){
  const el=document.getElementById('block-name-input');
  const newName=el?el.value.trim():'';
  state.editingBlockName=false;
  if(newName&&state.activeBlock&&newName!==state.activeBlock.name){
    state.activeBlock.name=newName;
    saveBlocks();
  }
  render();
}

function startEditEx(key){ state.editingExKey=key; render(); setTimeout(()=>{ const el=document.getElementById('ex-edit-'+key); if(el){el.focus();el.select();} },50); }

function saveExName(key, oldName){
  const el=document.getElementById('ex-edit-'+esc(key));
  const newName=el?el.value.trim():oldName;
  state.editingExKey=null;
  if(!newName||newName===oldName.trim()){ render(); return; }

  // Rename exercise across all weeks/days in all blocks
  for(const block of state.blocks){
    for(const week of block.weeks){
      for(const day of week.days){
        const ex=day.exercises.find(e=>e.name.trim()===oldName.trim());
        if(!ex) continue;
        ex.name=newName;

        // Migrate log keys: old key → new key
        const oldKey=lk(block.id,week.label,day.name,oldName.trim());
        const newKey=lk(block.id,week.label,day.name,newName);
        if(state.logs[oldKey]!==undefined){
          state.logs[newKey]=state.logs[oldKey];
          delete state.logs[oldKey];
        }
        // Migrate set keys
        for(let si=0;si<20;si++){
          const osk=oldKey+`||s${si}`;
          const nsk=newKey+`||s${si}`;
          if(state.logs[osk]!==undefined){
            state.logs[nsk]=state.logs[osk];
            delete state.logs[osk];
          }
        }
      }
    }
  }

  // Migrate tracked lifts entry
  const otn=oldName.trim().toLowerCase();
  const ntn=newName.toLowerCase();
  if(state.trackedLifts[otn]!==undefined){
    state.trackedLifts[ntn]=state.trackedLifts[otn];
    delete state.trackedLifts[otn];
    saveTrackedLifts();
  }

  saveLogs();
  saveBlocks();
  render();
}

function toggleEx(key){
  const l=state.logs[key]||{};
  const nowDone=!l.done;
  state.logs[key]={...l,done:nowDone,skipped:false};
  const block=state.activeBlock;
  const week=block?.weeks[state.activeWeek];
  const day=week?.days[state.activeDay];
  if(day){
    const ex=day.exercises.find(e=>lk(block.id,week.label,day.name,e.name)===key);
    if(nowDone && ex){
      // Checking exercise ON → mark all its sets done too
      const pres=ex.prescription;
      const sets=pres?parseSets(pres):[];
      const simple=parseSimple(pres);
      const ranged=(!sets.length&&!simple)?parseRangeSet(pres):null;
      const numSets=sets.length||(simple?.sets||0)||(ranged?.sets||0)||(pres?1:0)||1;
      for(let si=0;si<numSets;si++){
        const sk=key+`||s${si}`;
        const sl=state.logs[sk]||{};
        if(!sl.done) state.logs[sk]={...sl,done:true};
      }
    } else if(!nowDone){
      // Unchecking exercise → clear force-complete flag
      const fk=lk(block.id,week.label,day.name,'__complete__');
      delete state.logs[fk];
    }
  }
  saveLogs(); render();
}

function completeWorkout(){
  const block=state.activeBlock;
  const week=block.weeks[state.activeWeek];
  const day=week?.days[state.activeDay];
  if(!day) return;
  // Mark all exercises and their sets as done
  day.exercises.forEach(ex=>{
    const key=lk(block.id,week.label,day.name,ex.name);
    const log=state.logs[key]||{};
    if(!log.done) state.logs[key]={...log,done:true,skipped:false};
    // Mark individual sets done with prescribed weight if not already logged
    const pres=ex.prescription;
    if(pres){
      const sets=parseSets(pres);
      const simple=parseSimple(pres);
      const ranged=(!sets.length&&!simple)?parseRangeSet(pres):null;
      const numSets=sets.length||(simple?.sets||0)||(ranged?.sets||0)||1;
      for(let si=0;si<numSets;si++){
        const sk=key+`||s${si}`;
        const sl=state.logs[sk]||{};
        if(!sl.done){
          const setEntry={done:true};
          if(!sl.actual&&sets[si]&&!sets[si].isRpe) setEntry.actual=String(sets[si].weight);
          state.logs[sk]={...sl,...setEntry};
        }
      }
    }
  });
  // Set force-complete flag so isDayComplete() returns true
  const forceKey=lk(block.id,week.label,day.name,'__complete__');
  state.logs[forceKey]={done:true};
  saveLogs();
  render();
}
function clearWorkout(){
  const block=state.activeBlock;
  const week=block.weeks[state.activeWeek];
  const day=week?.days[state.activeDay];
  if(!day) return;
  // Delete all log keys for this day
  day.exercises.forEach(ex=>{
    const key=lk(block.id,week.label,day.name,ex.name);
    delete state.logs[key];
    for(let si=0;si<20;si++){
      const sk=key+`||s${si}`;
      if(state.logs[sk]!==undefined) delete state.logs[sk];
    }
  });
  // Clear force-complete flag
  delete state.logs[lk(block.id,week.label,day.name,'__complete__')];
  saveLogs();
  render();
}

function toggleSkip(key){
  const log=state.logs[key]||{};
  const isSkipped=log.skipped||false;
  state.logs[key]={...log, skipped:!isSkipped, done:false};
  saveLogs(); render();
}

// A day is complete if:
// 1. All exercises are done or skipped, OR
// 2. Force-complete flag is set (via Complete Workout button)
function isDayComplete(block, week, day){
  if(!day||day.exercises.length===0) return false;
  // Check force-complete flag
  const forceKey=lk(block.id,week.label,day.name,'__complete__');
  if(state.logs[forceKey]?.done) return true;
  // Require all exercises resolved
  const total=day.exercises.length;
  const resolved=day.exercises.filter(ex=>{
    const log=state.logs[lk(block.id,week.label,day.name,ex.name)]||{};
    return log.done||log.skipped;
  }).length;
  return resolved===total;
}
function toggleSet(key){
  const l=state.logs[key]||{};
  state.logs[key]={...l,done:!l.done};
  saveLogs();
  autoCompleteExercise(key);
  render();
}
function adjustSets(key, delta){
  const cur = state.extraSets[key] || 0;
  const next = Math.max(0, cur + delta);
  if(delta < 0 && cur > 0){
    const block=state.activeBlock, week=block.weeks[state.activeWeek], day=week.days[state.activeDay];
    const ex=day.exercises.find(e=>lk(block.id,week.label,day.name,e.name)===key);
    if(ex){
      const baseCount=(ex.sets&&ex.sets.length>0)?ex.sets.length:(parseSimple(ex.prescription)||{sets:1}).sets;
      const removedIdx=baseCount+cur-1;
      const sk=key+`||s${removedIdx}`;
      delete state.logs[sk];
      saveLogs();
    }
  }
  state.extraSets[key]=next;
  render();
}
function setActual(key,v){
  state.logs[key]={...(state.logs[key]||{}),actual:v};
  // Auto-complete set when weight is entered
  const shouldCheck=v&&v.trim()!=='';
  state.logs[key].done=shouldCheck;
  saveLogs();
  
  // Update set checkmark directly without full render
  updateSetCheckmark(key,shouldCheck);
  
  // Check if all sets are now done → auto-complete exercise
  autoCompleteExercise(key);
}
function setRpe(key,v){
  state.logs[key]={...(state.logs[key]||{}),rpe:v};
  saveLogs();
  // RPE doesn't trigger checkmark, but might trigger exercise complete
  autoCompleteExercise(key);
}
function updateSetCheckmark(key,isDone){
  // Find the button with onclick="toggleSet('KEY')" and update it
  const escaped=key.replace(/'/g,"\\'");
  const btn=document.querySelector(`button.set-check[onclick*="${escaped}"]`);
  if(btn){
    btn.className=isDone?'set-check done':'set-check';
    btn.textContent=isDone?'✓':'○';
  }
}
function autoCompleteExercise(setKey){
  // Extract exercise key from set key: blockId||week||day||exercise||sN → blockId||week||day||exercise
  const parts=setKey.split('||');
  if(parts.length!==5) return; // Not a set key
  const exKey=parts.slice(0,4).join('||');
  
  // Count sets for this exercise
  const block=state.activeBlock;
  if(!block) return;
  const week=block.weeks[state.activeWeek];
  if(!week) return;
  const day=week.days[state.activeDay];
  if(!day) return;
  const ex=day.exercises.find(e=>lk(block.id,week.label,day.name,e.name)===exKey);
  if(!ex) return;
  
  const pres=ex.prescription;
  const sets=pres?parseSets(pres):[];
  const simple=parseSimple(pres);
  const ranged=(!sets.length&&!simple)?parseRangeSet(pres):null;
  const totalSets=sets.length||(simple?.sets||0)||(ranged?.sets||0)||(pres?1:0)||1;
  
  // Check if all sets done
  let allDone=true;
  for(let si=0;si<totalSets;si++){
    const sk=exKey+`||s${si}`;
    if(!state.logs[sk]?.done){ allDone=false; break; }
  }
  
  // If all sets done, mark exercise done and update checkmark directly
  if(allDone&&!state.logs[exKey]?.done){
    state.logs[exKey]={...(state.logs[exKey]||{}),done:true};
    saveLogs();
    // Update main exercise checkmark without full render
    updateExerciseCheckmark(exKey,true);
  } else if(!allDone&&state.logs[exKey]?.done){
    // If sets were unchecked, uncheck exercise and clear force-complete flag
    state.logs[exKey]={...(state.logs[exKey]||{}),done:false};
    const _b=state.activeBlock,_w=_b?.weeks[state.activeWeek],_d=_w?.days[state.activeDay];
    if(_d){ const fk=lk(_b.id,_w.label,_d.name,'__complete__'); delete state.logs[fk]; }
    saveLogs();
    updateExerciseCheckmark(exKey,false);
  }
}
function updateExerciseCheckmark(exKey,isDone){
  // Find the main exercise toggle button
  const escaped=exKey.replace(/'/g,"\\'");
  const btn=document.querySelector(`button.exercise-check[onclick*="toggleEx('${escaped}')"]`);
  if(btn){
    btn.className=isDone?'exercise-check done':'exercise-check';
    btn.textContent=isDone?'✓':'';
  }
}
function setNote(key,v){ state.logs[key]={...(state.logs[key]||{}),notes:v}; saveLogs(); }
function getPrevWeekNote(blockId,weekLabel,dayName,exName){
  // Find the most recent previous week that has a lifter note for this exercise
  const block=state.blocks.find(b=>b.id===blockId);
  if(!block) return null;
  const curIdx=block.weeks.findIndex(w=>w.label===weekLabel);
  if(curIdx<=0) return null;
  // Search backwards through previous weeks
  for(let i=curIdx-1;i>=0;i--){
    const w=block.weeks[i];
    const day=w.days.find(d=>d.name===dayName);
    if(!day) continue;
    const ex=day.exercises.find(e=>e.name===exName);
    if(!ex) continue;
    const key=[blockId,w.label,dayName,exName].join('||');
    const note=state.logs[key]?.notes;
    if(note&&note.trim()) return note.trim();
  }
  return null;
}
function getPrevWeekPerformance(blockId,weekLabel,dayName,exName){
  function getSets(key){
    const sets=[];
    for(let si=0;si<20;si++){
      const sl=state.logs[key+'||s'+si];
      if(!sl) break;
      sets.push({actual:sl.actual||'—',rpe:sl.rpe||'',done:sl.done});
    }
    return sets;
  }
  // Phase 1: search current block backwards
  const block=state.blocks.find(b=>b.id===blockId);
  if(block){
    const curIdx=block.weeks.findIndex(w=>w.label===weekLabel);
    for(let i=(curIdx>0?curIdx-1:block.weeks.length-1);i>=0;i--){
      if(i>=curIdx) break;
      const w=block.weeks[i];
      const day=w.days.find(d=>d.name===dayName);
      if(!day) continue;
      if(!day.exercises.find(e=>e.name===exName)) continue;
      const key=[blockId,w.label,dayName,exName].join('||');
      if(!state.logs[key]?.done) continue;
      const sets=getSets(key);
      if(sets.length>0) return {label:w.label,source:null,sets};
    }
  }
  // Phase 2: search other blocks (most recent first)
  for(let bi=state.blocks.length-1;bi>=0;bi--){
    const b=state.blocks[bi];
    if(b.id===blockId) continue;
    for(let wi=b.weeks.length-1;wi>=0;wi--){
      const w=b.weeks[wi];
      for(const d of w.days){
        if(!d.exercises.find(e=>e.name===exName)) continue;
        const key=[b.id,w.label,d.name,exName].join('||');
        if(!state.logs[key]?.done) continue;
        const sets=getSets(key);
        if(sets.length>0) return {label:w.label,source:b.name||b.id,sets};
      }
    }
  }
  return null;
}

function toggleExpand(key, groupEncoded){
  const groupKeys=groupEncoded?groupEncoded.split(':::'):null;
  if(groupKeys&&groupKeys.length>1){
    const allOpen=groupKeys.every(k=>state.expandedEx.has(k));
    if(allOpen){ groupKeys.forEach(k=>state.expandedEx.delete(k)); }
    else { groupKeys.forEach(k=>state.expandedEx.add(k)); }
  } else {
    if(state.expandedEx.has(key)){ state.expandedEx.delete(key); }
    else { state.expandedEx.add(key); }
  }
  render();
}
function findNextWorkout(block){
  if(!block) return {weekIdx:0, dayIdx:0};
  for(let wi=0;wi<block.weeks.length;wi++){
    const week=block.weeks[wi];
    for(let di=0;di<week.days.length;di++){
      if(!isDayComplete(block,week,week.days[di])) return {weekIdx:wi, dayIdx:di};
    }
  }
  // All complete — stay on last day
  const lastWi=block.weeks.length-1;
  return {weekIdx:lastWi, dayIdx:(block.weeks[lastWi]?.days.length||1)-1};
}
function setWeek(wi){ state.activeWeek=wi; state.activeDay=0; state.expandedEx=new Set(); saveNav(); render(); }
function setDay(di){ state.activeDay=di; state.expandedEx=new Set(); saveNav(); render(); }
function switchBlock(id){ const b=state.blocks.find(b=>b.id===id); if(b){ const next=findNextWorkout(b); state.activeBlock=b; state.activeWeek=next.weekIdx; state.activeDay=next.dayIdx; state.editingBlockName=false; saveNav(); render(); } }

// ── GOOGLE DRIVE PICKER ───────────────────────────────────────────────────────
const GAPI_KEY = 'AIzaSyAyDMjaar1LL7u8CbAiVx6RInQA_p2RrtM';
const OAUTH_CLIENT_ID = '868418344070-756bh89t1d5ms7d50e0ofvo3tuent9kl.apps.googleusercontent.com';
const PICKER_SCOPE = 'https://www.googleapis.com/auth/drive.readonly';

let gapiReady = false;
let tokenClient = null;
let accessToken = null;
let apisLoading = false;
let apisLoaded = false;

// Preload APIs as soon as page loads so they're ready when user taps
function preloadDriveApis(){
  if(apisLoading||apisLoaded) return;
  apisLoading=true;
  const s1=document.createElement('script'); s1.src='https://apis.google.com/js/api.js';
  s1.onload=()=>{ gapi.load('picker',()=>{ gapiReady=true; checkApisReady(); }); };
  document.head.appendChild(s1);
  const s2=document.createElement('script'); s2.src='https://accounts.google.com/gsi/client';
  s2.onload=()=>{ checkApisReady(); };
  document.head.appendChild(s2);
}

function checkApisReady(){
  if(gapiReady && typeof google !== 'undefined' && google.accounts){
    apisLoaded=true;
    tokenClient=google.accounts.oauth2.initTokenClient({
      client_id: OAUTH_CLIENT_ID,
      scope: PICKER_SCOPE,
      callback:(resp)=>{
        if(resp.error){ alert('Google sign-in failed: '+resp.error); return; }
        accessToken=resp.access_token;
        showPicker();
      }
    });
  }
}

// Called directly on tap — must be synchronous to avoid popup blocker
function openDrivePicker(){
  if(!apisLoaded){
    // APIs not ready yet — show loading state and retry
    alert('Google Drive is loading, please try again in a moment.');
    preloadDriveApis();
    return;
  }
  if(accessToken){ showPicker(); return; }
  // This must happen synchronously on user tap
  tokenClient.requestAccessToken({prompt:'select_account'});
}

function showPicker(){
  const picker=new google.picker.PickerBuilder()
    .addView(new google.picker.DocsView()
      .setIncludeFolders(true)
      .setMimeTypes('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel'))
    .setOAuthToken(accessToken)
    .setDeveloperKey(GAPI_KEY)
    .setCallback(pickerCallback)
    .build();
  picker.setVisible(true);
}

async function pickerCallback(data){
  if(data.action!==google.picker.Action.PICKED) return;
  const file=data.docs[0];
  try{
    const resp=await fetch(
      `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`,
      {headers:{Authorization:`Bearer ${accessToken}`}}
    );
    if(!resp.ok) throw new Error('Download failed: '+resp.status);
    const wb=XLSX.read(await resp.arrayBuffer());
    const blocks=parseWorkbook(wb);
    if(!blocks||blocks.length===0){ alert("Couldn't parse this file."); return; }
    const namePart=file.name.replace(/\.xlsx?$/i,'').replace(/_/g,' ').trim();
    blocks.forEach(b=>{ if(b.athleteName==='Athlete') b.athleteName=namePart; });
    mergeBlocks(blocks); const _n=findNextWorkout(state.activeBlock); state.activeWeek=_n.weekIdx; state.activeDay=_n.dayIdx; state.screen='workout';
    autoRegisterCompLifts(blocks);
    saveBlocks(); saveNav();
    document.getElementById('nav-workout').classList.add('active');
    document.getElementById('nav-metrics').classList.remove('active');
    render();
  }catch(err){ alert('Error loading file from Drive: '+err.message); console.error(err); }
}

// Start preloading immediately
window.addEventListener('load', preloadDriveApis);

document.getElementById('file-input').addEventListener('change',async(e)=>{
  const file=e.target.files?.[0]; if(!file) return;
  try{
    const data=await file.arrayBuffer();
    const wb=XLSX.read(data);
    const blocks=parseWorkbook(wb);
    if(!blocks||blocks.length===0){ alert("Couldn't parse this file. See console for details."); return; }
    // Pull athlete name from filename
    const namePart=file.name.replace(/\.xlsx?$/i,'').replace(/_/g,' ').trim();
    blocks.forEach(b=>{ if(b.athleteName==='Athlete') b.athleteName=namePart; });
    mergeBlocks(blocks); const _n2=findNextWorkout(state.activeBlock); state.activeWeek=_n2.weekIdx; state.activeDay=_n2.dayIdx; state.screen='workout';
    autoRegisterCompLifts(blocks);
    saveBlocks(); saveNav();
    document.getElementById('nav-workout').classList.add('active');
    document.getElementById('nav-metrics').classList.remove('active');
    render();
  }catch(err){ alert('Error reading file: '+err.message); console.error(err); }
  e.target.value='';
});

// ── PROGRAM MANAGER ───────────────────────────────────────────────────────────
let _pendingDeleteBlockId=null;

function openProgramModal(){
  renderProgramList();
  document.getElementById('program-modal').style.display='flex';
}
function closeProgramModal(){
  document.getElementById('program-modal').style.display='none';
}
function renderProgramList(){
  const list=document.getElementById('program-list');
  if(!state.blocks.length){ list.innerHTML='<div style="font-size:13px;color:#444;padding:8px 0">No programs loaded yet.</div>'; return; }
  let h='<div class="add-lift-group-label" style="margin-bottom:8px">Existing Programs</div>';
  state.blocks.forEach(block=>{
    const isCurrent=state.activeBlock&&state.activeBlock.id===block.id;
    const weeks=block.weeks?.length||0;
    h+=`<div class="program-item" style="flex-wrap:wrap;">
      <div class="program-item-info" onclick="selectBlock('${esc(block.id)}')">
        <div class="program-item-name${isCurrent?' active-cycle':''}">${esc(block.name)}</div>
        <div class="program-item-meta">${weeks} weeks${block.dateRange?' · '+block.dateRange:''}</div>
      </div>
      <div class="program-item-actions">
        <button class="program-select-btn${isCurrent?' current':''}" onclick="selectBlock('${esc(block.id)}')">${isCurrent?'ACTIVE':'SELECT'}</button>
        <button class="program-delete-btn" onclick="promptDeleteBlock('${esc(block.id)}')" title="Delete program"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6M14 11v6"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg></button>
      </div>
    </div>`;
  });
  list.innerHTML=h;
}
function selectBlock(blockId){
  const block=state.blocks.find(b=>b.id===blockId);
  if(!block) return;
  state.activeBlock=block; state.activeWeek=0; state.activeDay=0;
  closeProgramModal();
  render();
}
function promptDeleteBlock(blockId){
  const block=state.blocks.find(b=>b.id===blockId);
  if(!block) return;
  _pendingDeleteBlockId=blockId;
  document.getElementById('delete-modal-name').textContent=block.name;
  document.getElementById('delete-modal').style.display='flex';
}
function closeDeleteModal(){
  _pendingDeleteBlockId=null;
  document.getElementById('delete-modal').style.display='none';
}
function confirmDeleteBlock(){
  if(!_pendingDeleteBlockId) return;
  const blockId=_pendingDeleteBlockId;
  for(const key of Object.keys(state.logs)){
    if(key.startsWith(blockId+'||')) delete state.logs[key];
  }
  saveLogs();
  state.blocks=state.blocks.filter(b=>b.id!==blockId);
  if(state.activeBlock?.id===blockId){
    state.activeBlock=state.blocks[state.blocks.length-1]||null;
    state.activeWeek=0; state.activeDay=0;
  }
  saveBlocks();
  closeDeleteModal();
  closeProgramModal();
  render();
}

document.getElementById('new-btn').addEventListener('click', openProgramModal);
// ── EXPORT REPORT ─────────────────────────────────────────────────────────────
function openExportModal(blockId) {
  const existing = document.getElementById('export-modal-overlay');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.className = 'export-modal-overlay';
  overlay.id = 'export-modal-overlay';
  overlay.onclick = (e) => { if (e.target === overlay) closeExportModal(); };

  overlay.innerHTML = `
  <div class="export-modal">
    <div class="export-modal-header">
      <span class="export-modal-title">Export</span>
      <button class="export-modal-close" onclick="closeExportModal()">✕</button>
    </div>

    <!-- Training Log Card -->
    <div class="export-card">
      <div class="export-card-header">
        <svg class="export-card-icon" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect width="36" height="36" rx="8" fill="#1D6F42"/>
          <rect x="7" y="9" width="22" height="3" rx="1" fill="white" opacity="0.9"/>
          <rect x="7" y="14" width="22" height="1.5" rx="0.75" fill="white" opacity="0.4"/>
          <rect x="7" y="17.5" width="22" height="1.5" rx="0.75" fill="white" opacity="0.4"/>
          <rect x="7" y="21" width="22" height="1.5" rx="0.75" fill="white" opacity="0.4"/>
          <rect x="7" y="24.5" width="14" height="1.5" rx="0.75" fill="white" opacity="0.4"/>
          <rect x="23" y="22" width="7" height="7" rx="1" fill="#1D6F42"/>
          <path d="M24.5 25.5L26.5 27.5L29 24" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <div class="export-card-info">
          <div class="export-card-name">Training Log</div>
          <div class="export-card-desc">Full workout log with prescribed vs. actual sets — Excel file</div>
        </div>
      </div>
      <div class="export-scope-toggle">
        <button class="export-scope-pill active" id="log-scope-week" onclick="setLogScope('week')">This Week</button>
        <button class="export-scope-pill" id="log-scope-full" onclick="setLogScope('full')">Full Block</button>
      </div>
      <button class="export-action-btn" onclick="exportTrainingLog('${blockId}')">Download Excel</button>
    </div>

    <!-- Training Report Card -->
    <div class="export-card">
      <div class="export-card-header">
        <svg class="export-card-icon" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect width="36" height="36" rx="8" fill="#141414" stroke="#2a2a2a"/>
          <polyline points="7,26 13,18 18,21 23,13 29,8" stroke="#C9A84C" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <circle cx="13" cy="18" r="1.5" fill="#C9A84C"/>
          <circle cx="18" cy="21" r="1.5" fill="#C9A84C"/>
          <circle cx="23" cy="13" r="1.5" fill="#C9A84C"/>
          <line x1="7" y1="28" x2="29" y2="28" stroke="#333" stroke-width="1"/>
        </svg>
        <div class="export-card-info">
          <div class="export-card-name">Training Report</div>
          <div class="export-card-desc">Squat / Bench / Deadlift progressions with charts — full block</div>
        </div>
      </div>
      <button class="export-action-btn" onclick="exportHTMLReport('${blockId}','full');closeExportModal()">Open Report</button>
      <div style="text-align:center;font-size:11px;color:#444;margin-top:8px;letter-spacing:0.03em">Save as PDF via share sheet ↑</div>
    </div>
  </div>`;

  document.body.appendChild(overlay);
  // Default log scope state
  overlay._logScope = 'week';
}

function closeExportModal() {
  const overlay = document.getElementById('export-modal-overlay');
  if (overlay) overlay.remove();
}

function setLogScope(scope) {
  const overlay = document.getElementById('export-modal-overlay');
  if (!overlay) return;
  overlay._logScope = scope;
  document.getElementById('log-scope-week').classList.toggle('active', scope === 'week');
  document.getElementById('log-scope-full').classList.toggle('active', scope === 'full');
}

function exportTrainingLog(blockId) {
  const overlay = document.getElementById('export-modal-overlay');
  const scope = overlay ? overlay._logScope : 'full';

  const block = state.blocks.find(b => b.id === blockId);
  if (!block) return;

  let weeks = block.weeks || [];
  if (scope === 'week') {
    const activeWeekLabel = block.weeks[state.activeWeek]?.label;
    weeks = block.weeks.filter(w => w.label === activeWeekLabel);
    if (!weeks.length) { alert('No data for current week.'); return; }
  }

  const blockLogs = {};
  for (const [key, val] of Object.entries(state.logs)) {
    if (key.startsWith(blockId + '||')) blockLogs[key] = val;
  }

  const wb = XLSX.utils.book_new();

  // Style presets
  const DAY_HEAD_STYLE = {
    font: { bold: true, sz: 11, color: { rgb: 'FFFFFF' } },
    fill: { fgColor: { rgb: '111111' }, patternType: 'solid' },
    alignment: { horizontal: 'left', vertical: 'center' }
  };

  for (const week of weeks) {
    const rows = [];
    const styleMap = {};
    const r = () => rows.length;
    const days = week.days || [];

    for (let di = 0; di < days.length; di++) {
      const day = days[di];

      // Blank separator between day blocks (not before first)
      if (di > 0) rows.push([]);

      // Day header row: day name + column labels
      rows.push([day.name, 'Sets × Reps @RPE', 'Record Weight & RPE', 'Coach Notes', 'Lifter Notes']);
      styleMap[r() - 1] = DAY_HEAD_STYLE;

      for (const ex of (day.exercises || [])) {
        // Determine set count from prescription parsers
        const sets = parseSets(ex.prescription) || [];
        let setCount = sets.length;
        let fallbackReps = null;
        if (!setCount) {
          const simple = parseSimple(ex.prescription);
          const ranged = parseRangeSet(ex.prescription);
          const bare = parseBarePres(ex.prescription);
          setCount = (simple && simple.sets) || (ranged && ranged.sets) || (bare && bare.sets) || 1;
          fallbackReps = (simple && simple.reps) || (ranged && ranged.reps) || (bare && bare.reps) || null;
        }

        // Include extra sets added via "+ Set"
        const exKey = [blockId, week.label, day.name, ex.name].join('||');
        const extra = state.extraSets ? (state.extraSets[exKey] || 0) : 0;
        const totalSets = setCount + extra;

        // Check if skipped
        const exLog = blockLogs[exKey] || {};
        let loggedStr = '';

        if (exLog.skipped) {
          loggedStr = 'SKIPPED';
        } else {
          // Collect logged set entries into collapsed string
          const loggedParts = [];
          for (let si = 0; si < totalSets; si++) {
            const sk = exKey + '||s' + si;
            const log = blockLogs[sk] || {};
            if (log.actual || log.done) {
              const weight = log.actual || (sets[si] && !sets[si].isRpe ? String(sets[si].weight) : '');
              const repsRaw = sets[si] ? sets[si].reps : fallbackReps;
              const reps = repsRaw === 'open' ? '?' : (repsRaw || '?');
              let part = weight ? `${weight}x${reps}` : `${reps} reps`;
              if (log.rpe) part += ` @${log.rpe}`;
              loggedParts.push(part);
            }
          }
          loggedStr = loggedParts.join(', ');
        }

        // Coach notes: ex.note + ex.coachNotes[]
        const coachParts = [];
        if (ex.note) coachParts.push(ex.note);
        if (ex.coachNotes && ex.coachNotes.length) coachParts.push(...ex.coachNotes);
        const coachNotesStr = coachParts.join('; ');

        // Lifter notes from logs
        const lifterNotes = exLog.notes || '';

        // Single row per exercise
        rows.push([ex.name, ex.prescription || '', loggedStr, coachNotesStr, lifterNotes]);
      }
    }

    // Build sheet
    const ws = XLSX.utils.aoa_to_sheet(rows);

    // Column widths
    ws['!cols'] = [
      { wch: 32 }, // Exercise name
      { wch: 30 }, // Prescription
      { wch: 38 }, // Logged
      { wch: 28 }, // Coach Notes
      { wch: 28 }, // Lifter Notes
    ];

    // Apply styles
    const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
    for (let R = range.s.r; R <= range.e.r; R++) {
      const style = styleMap[R];
      if (!style) continue;
      for (let C = range.s.c; C <= range.e.c; C++) {
        const addr = XLSX.utils.encode_cell({ r: R, c: C });
        if (!ws[addr]) ws[addr] = { t: 's', v: '' };
        ws[addr].s = style;
      }
    }

    // Sheet name: "W1", "W2", etc. — XLSX sheet names max 31 chars
    const sheetName = week.label.replace(/[:\\/?*[\]]/g, '').slice(0, 31);
    XLSX.utils.book_append_sheet(wb, ws, sheetName);
  }

  const dateStr = new Date().toISOString().slice(0, 10);
  const safeName = block.name.replace(/[^a-z0-9]/gi, '-').toLowerCase();
  const scopeStr = scope === 'week' ? '-' + (block.weeks[state.activeWeek]?.label || 'week').toLowerCase().replace(/\s+/g, '') : '';
  XLSX.writeFile(wb, `${safeName}-training-log${scopeStr}-${dateStr}.xlsx`, { cellStyles: true });

  closeExportModal();
}

function exportHTMLReport(blockId, scope) {
  const block = state.blocks.find(b => b.id === blockId);
  if (!block) return;

  const weeks = block.weeks || [];

  const blockLogs = {};
  for (const [key, val] of Object.entries(state.logs)) {
    if (key.startsWith(blockId + '||')) blockLogs[key] = val;
  }

  // ── Palette for multi-line charts (one color per variation) ──────────────
  const FAMILY_COLORS = [
    '#C9A84C', // gold
    '#7B9FD4', // blue
    '#7EC89A', // green
    '#D47B7B', // red
    '#B07BD4', // purple
    '#D4A97B', // orange
    '#7BD4D4', // teal
  ];

  // ── Gather data grouped by family, then by exercise ──────────────────────
  // Source: LIFT_GROUPS (not isTracked) — all barbell variations included
  const families = { squat: {}, bench: {}, deadlift: {} };
  const peakByGroup = { squat: null, bench: null, deadlift: null };

  for (const [key, val] of Object.entries(blockLogs)) {
    const parts = key.split('||');
    if (parts.length < 5 || !parts[4].startsWith('s')) continue;
    const exName = parts[3];
    const group = classifyLift(exName);
    if (!group || !families[group]) continue; // skip non-big-3

    const si = parseInt(parts[4].slice(1));
    const weight = val.actual ? parseFloat(val.actual) : getPrescribedWeight(parts[0], parts[1], parts[2], exName, si);
    if (!weight || isNaN(weight) || weight <= 0) continue;
    const reps = getSetReps(parts[0], parts[1], parts[2], exName, si);
    if (!reps) continue;
    const rpe = val.rpe ? parseFloat(val.rpe) : null;
    const result = calc1rm(weight, reps, rpe);
    if (!result) continue;

    const weekLabel = parts[1];
    if (!families[group][exName]) families[group][exName] = {};
    if (!families[group][exName][weekLabel])
      families[group][exName][weekLabel] = { e1rm: 0, topWeight: 0, topReps: 0, topRpe: null, tonnage: 0, method: 'epley' };
    const w = families[group][exName][weekLabel];
    w.tonnage += weight * reps;
    if (result.value > w.e1rm) { w.e1rm = result.value; w.topWeight = weight; w.topReps = reps; w.topRpe = rpe; w.method = result.method; }

    // Peak for 1RM projection — comp lifts only
    if (isCompLift(exName)) {
      if (!peakByGroup[group] || result.value > peakByGroup[group]) peakByGroup[group] = result.value;
    }
  }

  // ── Summary page data ─────────────────────────────────────────────────────
  let totalSets = 0, totalVolume = 0;
  const volumeByFamily = { squat: 0, bench: 0, deadlift: 0, other: 0 };
  const volumeByWeek = {}; // { weekLabel: { squat, bench, deadlift, other, total } }
  const peakSetByFamily = { squat: null, bench: null, deadlift: null };

  for (const [key, val] of Object.entries(blockLogs)) {
    const parts = key.split('||');
    if (parts.length < 5 || !parts[4].startsWith('s')) continue;
    const exName = parts[3];
    const weekLabel = parts[1];
    const si = parseInt(parts[4].slice(1));
    const weight = val.actual ? parseFloat(val.actual) : getPrescribedWeight(parts[0], parts[1], parts[2], exName, si);
    if (!weight || isNaN(weight) || weight <= 0) continue;
    const reps = getSetReps(parts[0], parts[1], parts[2], exName, si);
    if (!reps || isNaN(reps)) continue;

    const setVol = weight * reps;
    const group = classifyLift(exName) || 'other';

    totalSets++;
    totalVolume += setVol;
    volumeByFamily[group] = (volumeByFamily[group] || 0) + setVol;

    if (!volumeByWeek[weekLabel]) volumeByWeek[weekLabel] = { squat: 0, bench: 0, deadlift: 0, other: 0 };
    volumeByWeek[weekLabel][group] = (volumeByWeek[weekLabel][group] || 0) + setVol;

    // Track peak set per family (heaviest single set by weight)
    if (group !== 'other') {
      if (!peakSetByFamily[group] || weight > peakSetByFamily[group].weight) {
        peakSetByFamily[group] = { weight, reps, name: exName };
      }
    }
  }

  const sortedWeekLabels = Object.keys(volumeByWeek).sort((a, b) => sessionOrder(a) - sessionOrder(b));
  const weekVolTotals = sortedWeekLabels.map(wl =>
    (volumeByWeek[wl].squat || 0) + (volumeByWeek[wl].bench || 0) + (volumeByWeek[wl].deadlift || 0) + (volumeByWeek[wl].other || 0)
  );

  // Week-by-week completion grid
  let weekGridHtml = '';
  for (const week of weeks) {
    const daysTotal = week.days.length;
    const daysDone = week.days.filter(d => isDayComplete(block, week, d)).length;
    const allDone = daysDone === daysTotal;
    const dotHtml = week.days.map(d => {
      const done = isDayComplete(block, week, d);
      return `<span class="day-dot${done ? ' done' : ''}"></span>`;
    }).join('');
    weekGridHtml += `<div class="week-row">
      <span class="week-row-label">${week.label}</span>
      <span class="week-row-dots">${dotHtml}</span>
      <span class="week-row-count${allDone ? ' all-done' : ''}">${daysDone}/${daysTotal}</span>
    </div>`;
  }

  // Peak sets html
  let peakSetsHtml = '';
  for (const [group, label] of [['squat','Squat'],['bench','Bench'],['deadlift','Deadlift']]) {
    const p = peakSetByFamily[group];
    peakSetsHtml += `<div class="peak-card">
      <div class="peak-label">${label}</div>
      <div class="peak-val">${p ? p.weight + '<span class="peak-unit"> lbs</span>' : '—'}</div>
      <div class="peak-set">${p ? `${p.weight}×${p.reps} ${p.name}` : 'No data'}</div>
    </div>`;
  }

  // Volume by family bar
  const famLabels = ['Squat','Bench','Deadlift','Other'];
  const famColors = ['#C9A84C','#7B9FD4','#7EC89A','#555'];
  const famVols = [volumeByFamily.squat||0, volumeByFamily.bench||0, volumeByFamily.deadlift||0, volumeByFamily.other||0];


  let totalDays = 0, completedDays = 0;
  for (const week of weeks) {
    for (const day of (week.days || [])) {
      totalDays++;
      if (isDayComplete(block, week, day)) completedDays++;
    }
  }
  const compliancePct = totalDays > 0 ? Math.round(completedDays / totalDays * 100) : 0;

  // ── 1RM Projections ───────────────────────────────────────────────────────
  let projectionsHtml = '';
  for (const [group, label] of [['squat','Squat'],['bench','Bench'],['deadlift','Deadlift']]) {
    const peak = peakByGroup[group];
    const lbs = peak ? Math.round(peak) : null;
    projectionsHtml += `<div class="proj-card">
      <div class="proj-lift">${label}</div>
      <div class="proj-val">${lbs ? lbs + '<span class="proj-unit"> lbs</span>' : '—'}</div>
    </div>`;
  }

  // ── Build family sections ─────────────────────────────────────────────────
  const chartInits = [];
  let familySectionsHtml = '';
  let anyData = false;

  for (const [groupKey, groupLabel] of [['squat','Squat'],['bench','Bench'],['deadlift','Deadlift']]) {
    const exercises = families[groupKey];
    const exNames = Object.keys(exercises).filter(n => Object.keys(exercises[n]).length > 0);
    if (!exNames.length) continue;
    anyData = true;

    // Collect all week labels across all exercises in this family, sorted
    const allWeekLabels = [...new Set(
      exNames.flatMap(n => Object.keys(exercises[n]))
    )].sort((a, b) => sessionOrder(a) - sessionOrder(b));

    // Legend dots
    const legendHtml = exNames.map((n, i) => {
      const color = FAMILY_COLORS[i % FAMILY_COLORS.length];
      return `<span class="legend-item"><span class="legend-dot" style="background:${color}"></span>${n}</span>`;
    }).join('');

    // Chart datasets — one per exercise
    const datasets = exNames.map((n, i) => {
      const color = FAMILY_COLORS[i % FAMILY_COLORS.length];
      const data = allWeekLabels.map(wl => exercises[n][wl] ? Math.round(exercises[n][wl].e1rm) : null);
      return {
        label: n,
        data,
        borderColor: color,
        backgroundColor: 'transparent',
        pointBackgroundColor: color,
        pointRadius: 4,
        pointHoverRadius: 6,
        tension: 0.3,
        spanGaps: true
      };
    });

    const chartId = 'chart_' + groupKey;
    chartInits.push({ id: chartId, labels: allWeekLabels, datasets });

    // Per-exercise tables
    let tablesHtml = '';
    for (let i = 0; i < exNames.length; i++) {
      const exName = exNames[i];
      const color = FAMILY_COLORS[i % FAMILY_COLORS.length];
      const sortedWeeks = Object.entries(exercises[exName]).sort((a, b) => sessionOrder(a[0]) - sessionOrder(b[0]));
      let prevE1rm = null;
      let rows = '';
      for (const [weekLabel, w] of sortedWeeks) {
        const e1rmRounded = Math.round(w.e1rm);
        let delta = '—';
        if (prevE1rm !== null) { const d = e1rmRounded - Math.round(prevE1rm); delta = (d >= 0 ? '+' : '') + d; }
        const deltaClass = delta === '—' ? '' : delta.startsWith('+') ? 'pos' : 'neg';
        const rpeStr = w.topRpe !== null ? `@${w.topRpe}` : '—';
        const badge = w.method === 'rpe' ? '<span class="badge rpe-badge">RPE</span>' : '<span class="badge est-badge">EST</span>';
        rows += `<tr>
          <td class="muted">${weekLabel}</td>
          <td>${w.topWeight}×${w.topReps}</td>
          <td class="muted">${rpeStr}</td>
          <td>${e1rmRounded} ${badge}</td>
          <td class="${deltaClass}">${delta}</td>
          <td class="muted">${Math.round(w.tonnage).toLocaleString()}</td>
        </tr>`;
        prevE1rm = w.e1rm;
      }
      tablesHtml += `
      <div class="ex-block">
        <div class="ex-block-name" style="border-left:3px solid ${color}">${exName}</div>
        <table class="lift-table">
          <thead><tr><th>Week</th><th>Top Set</th><th>RPE</th><th>e1RM (lbs)</th><th>Δ</th><th>Volume (lbs)</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
    }

    familySectionsHtml += `
    <div class="family-section">
      <div class="family-header">
        <span class="family-name">${groupLabel}</span>
        <span class="family-peak">${peakByGroup[groupKey] ? Math.round(peakByGroup[groupKey]) + ' lbs est. 1RM' : ''}</span>
      </div>
      <div class="legend">${legendHtml}</div>
      <div class="chart-wrap"><canvas id="${chartId}"></canvas></div>
      ${tablesHtml}
    </div>`;
  }

  // ── Chart init script ─────────────────────────────────────────────────────
  const chartScript = chartInits.map(c => `
  new Chart(document.getElementById('${c.id}'), {
    type: 'line',
    data: {
      labels: ${JSON.stringify(c.labels)},
      datasets: ${JSON.stringify(c.datasets)}
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: '#1a1a1a', borderColor: '#2a2a2a', borderWidth: 1,
          titleColor: '#aaa', bodyColor: '#aaa',
          callbacks: { label: ctx => ctx.dataset.label + ': ' + ctx.parsed.y + ' lbs' }
        }
      },
      scales: {
        x: { ticks: { color: '#555', font: { family: 'Barlow Condensed', size: 12 } }, grid: { color: '#1a1a1a' } },
        y: { ticks: { color: '#555', font: { family: 'Barlow Condensed', size: 12 } }, grid: { color: '#1a1a1a' } }
      }
    }
  });`).join('\n');

  const dateStr = new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
  const scopeLabel = `${block.weeks.length}-Week Program`;

  // ── Full HTML ─────────────────────────────────────────────────────────────
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${block.name} — Training Report</title>
<link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@400;600;700;900&family=Barlow:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"><\/script>
<style>
*{box-sizing:border-box;margin:0;padding:0}
html{background:#0a0a0a}
html,body{background:#0a0a0a;color:#f0f0f0;font-family:'Barlow',sans-serif;-webkit-font-smoothing:antialiased}
.report{max-width:680px;margin:0 auto;padding:32px 20px 80px}

.rpt-logo{font-family:'Barlow Condensed',sans-serif;font-weight:900;font-size:12px;letter-spacing:.14em;color:#C9A84C;text-transform:uppercase;margin-bottom:10px}
.rpt-title{font-family:'Barlow Condensed',sans-serif;font-weight:900;font-size:38px;line-height:1.05;letter-spacing:.02em;margin-bottom:8px}
.rpt-meta{font-size:13px;color:#555;display:flex;gap:16px;flex-wrap:wrap;margin-bottom:16px}
.compliance-track{height:3px;background:#1a1a1a;border-radius:2px;margin-bottom:5px}
.compliance-fill{height:100%;background:#4ade80;border-radius:2px}
.compliance-label{font-size:11px;color:#444}
.rpt-divider{border:none;border-top:1px solid #1a1a1a;margin:28px 0}
.section-title{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:11px;letter-spacing:.12em;text-transform:uppercase;color:#444;margin-bottom:12px}

.projections{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:36px}
.proj-card{background:#141414;border:1px solid #1e1e1e;border-radius:12px;padding:16px 12px;text-align:center}
.proj-lift{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:11px;letter-spacing:.1em;text-transform:uppercase;color:#444;margin-bottom:6px}
.proj-val{font-family:'Barlow Condensed',sans-serif;font-weight:900;font-size:34px;color:#C9A84C;line-height:1}
.proj-unit{font-size:14px;font-weight:400;color:#555}

.family-section{background:#141414;border:1px solid #1e1e1e;border-radius:12px;margin-bottom:20px;overflow:hidden}
.family-header{display:flex;align-items:baseline;justify-content:space-between;padding:16px 16px 0}
.family-name{font-family:'Barlow Condensed',sans-serif;font-weight:900;font-size:28px;letter-spacing:.02em}
.family-peak{font-size:11px;color:#555;letter-spacing:.04em}
.legend{display:flex;flex-wrap:wrap;gap:10px;padding:10px 16px 4px}
.legend-item{display:flex;align-items:center;gap:5px;font-size:11px;color:#888;font-family:'Barlow Condensed',sans-serif;letter-spacing:.04em}
.legend-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.chart-wrap{height:160px;padding:8px 12px 12px}

.ex-block{border-top:1px solid #1a1a1a}
.ex-block-name{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:13px;letter-spacing:.06em;text-transform:uppercase;color:#aaa;padding:10px 16px 6px;margin-left:0}

.lift-table{width:100%;border-collapse:collapse;font-size:13px}
.lift-table th{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:10px;letter-spacing:.1em;text-transform:uppercase;color:#333;padding:4px 16px 6px;text-align:left}
.lift-table td{padding:6px 16px;border-top:1px solid #111;color:#ccc}
.lift-table tr:last-child td{padding-bottom:12px}
.muted{color:#555!important}
.pos{color:#4ade80}
.neg{color:#f87171}
.badge{font-size:9px;font-family:'Barlow Condensed',sans-serif;font-weight:700;letter-spacing:.06em;border-radius:3px;padding:1px 4px;vertical-align:middle;margin-left:3px}
.rpe-badge{background:rgba(201,168,76,.15);color:#C9A84C;border:1px solid rgba(201,168,76,.25)}
.est-badge{background:#1a1a1a;color:#444;border:1px solid #2a2a2a}
.empty{text-align:center;padding:48px;color:#333;font-size:14px}

/* Summary page */
.summary-page{padding-bottom:40px}
.stat-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-bottom:24px}
.stat-card{background:#141414;border:1px solid #1e1e1e;border-radius:12px;padding:16px}
.stat-label{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:10px;letter-spacing:.12em;text-transform:uppercase;color:#444;margin-bottom:6px}
.stat-val{font-family:'Barlow Condensed',sans-serif;font-weight:900;font-size:32px;color:#fff;line-height:1}
.stat-unit{font-size:13px;font-weight:400;color:#555}
.stat-sub{font-size:11px;color:#444;margin-top:4px}

.peak-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:24px}
.peak-card{background:#141414;border:1px solid #1e1e1e;border-radius:12px;padding:14px 12px;text-align:center}
.peak-label{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:10px;letter-spacing:.1em;text-transform:uppercase;color:#444;margin-bottom:6px}
.peak-val{font-family:'Barlow Condensed',sans-serif;font-weight:900;font-size:26px;color:#C9A84C;line-height:1}
.peak-unit{font-size:12px;font-weight:400;color:#555}
.peak-set{font-size:10px;color:#444;margin-top:4px}

.week-grid{background:#141414;border:1px solid #1e1e1e;border-radius:12px;padding:12px 16px;margin-bottom:24px}
.week-row{display:flex;align-items:center;gap:10px;padding:6px 0;border-bottom:1px solid #111}
.week-row:last-child{border-bottom:none}
.week-row-label{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:12px;color:#555;width:36px;flex-shrink:0}
.week-row-dots{display:flex;gap:5px;flex:1}
.day-dot{width:10px;height:10px;border-radius:50%;background:#222;flex-shrink:0}
.day-dot.done{background:#4ade80}
.week-row-count{font-family:'Barlow Condensed',sans-serif;font-size:11px;color:#444;width:28px;text-align:right}
.week-row-count.all-done{color:#4ade80}

.vol-chart-wrap{background:#141414;border:1px solid #1e1e1e;border-radius:12px;padding:16px;margin-bottom:24px}
.vol-chart-title{font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:11px;letter-spacing:.1em;text-transform:uppercase;color:#444;margin-bottom:12px}
.vol-chart-inner{height:160px}

/* Save button */
.save-btn{position:fixed;bottom:24px;right:24px;background:#C9A84C;color:#000;border:none;border-radius:10px;padding:12px 20px;font-family:'Barlow Condensed',sans-serif;font-weight:700;font-size:13px;letter-spacing:.08em;text-transform:uppercase;cursor:pointer;box-shadow:0 4px 20px rgba(0,0,0,0.5);z-index:100}
.save-btn:active{opacity:0.85}

@media print{
  .save-btn{display:none}
  .report{padding:16px;max-width:100%}
  body{-webkit-print-color-adjust:exact;print-color-adjust:exact}
  .family-section{page-break-inside:avoid;break-inside:avoid}
  .vol-chart-wrap{page-break-inside:avoid;break-inside:avoid}
  .week-grid{page-break-inside:avoid;break-inside:avoid}
  .peak-grid{page-break-inside:avoid;break-inside:avoid}
  .stat-grid{page-break-inside:avoid;break-inside:avoid}
  .chart-wrap{page-break-inside:avoid;break-inside:avoid}
  .ex-block{page-break-inside:avoid;break-inside:avoid}
}
</style>
</head>
<body>
<div class="report">
  <!-- ── SUMMARY PAGE ── -->
  <div class="summary-page">
    <div class="rpt-logo">PowerliftingLog</div>
    <div class="rpt-title">${block.name}</div>
    <div class="rpt-meta">
      <span>${scopeLabel}</span><span>${dateStr}</span>${block.athleteName ? `<span>${block.athleteName}</span>` : ''}
    </div>
    <div class="compliance-track"><div class="compliance-fill" style="width:${compliancePct}%"></div></div>
    <div class="compliance-label">${compliancePct}% compliance · ${completedDays} of ${totalDays} days completed</div>

    <hr class="rpt-divider">
    <div class="section-title">Block Summary</div>
    <div class="stat-grid">
      <div class="stat-card">
        <div class="stat-label">Total Volume</div>
        <div class="stat-val">${Math.round(totalVolume / 1000)}k<span class="stat-unit"> lbs</span></div>
        <div class="stat-sub">${Math.round(totalVolume).toLocaleString()} lbs total</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Sets Completed</div>
        <div class="stat-val">${totalSets}<span class="stat-unit"></span></div>
        <div class="stat-sub">across ${completedDays} training days</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Squat Volume</div>
        <div class="stat-val">${Math.round((volumeByFamily.squat||0) / 1000)}k<span class="stat-unit"> lbs</span></div>
        <div class="stat-sub">${Math.round(((volumeByFamily.squat||0)/totalVolume)*100)||0}% of total</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Bench Volume</div>
        <div class="stat-val">${Math.round((volumeByFamily.bench||0) / 1000)}k<span class="stat-unit"> lbs</span></div>
        <div class="stat-sub">${Math.round(((volumeByFamily.bench||0)/totalVolume)*100)||0}% of total</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Deadlift Volume</div>
        <div class="stat-val">${Math.round((volumeByFamily.deadlift||0) / 1000)}k<span class="stat-unit"> lbs</span></div>
        <div class="stat-sub">${Math.round(((volumeByFamily.deadlift||0)/totalVolume)*100)||0}% of total</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Training Days</div>
        <div class="stat-val">${completedDays}<span class="stat-unit"> / ${totalDays}</span></div>
        <div class="stat-sub">${block.weeks.length}-week block</div>
      </div>
    </div>

    <div class="section-title">Peak Sets</div>
    <div class="peak-grid">${peakSetsHtml}</div>

    <div class="section-title">Weekly Completion</div>
    <div class="week-grid">${weekGridHtml}</div>
  </div>

  <!-- ── LIFT PROGRESSIONS ── -->
  <hr class="rpt-divider">
  <div class="section-title">1RM Projections</div>
  <div class="projections">${projectionsHtml}</div>

  <div class="section-title">Lift Progressions</div>
  ${anyData ? familySectionsHtml : '<div class="empty">No logged data found for main lifts.</div>'}
</div>
<button class="save-btn" onclick="savePDF()">⬇ Save as PDF</button>
<script>
function savePDF(){
  // Give charts time to fully render before print dialog
  setTimeout(() => window.print(), 300);
}

${chartScript}
<\/script>
</body>
</html>`;

  const blob = new Blob([html], { type: 'text/html' });
  window.open(URL.createObjectURL(blob), '_blank');
}

function exportReport(blockId, scope) {
  const block = state.blocks.find(b => b.id === blockId);
  if (!block) return;

  // Determine which weeks to include
  let weeks = block.weeks || [];
  if (scope === 'week') {
    const activeWeekLabel = block.weeks[state.activeWeek]?.label;
    weeks = block.weeks.filter(w => w.label === activeWeekLabel);
    if (!weeks.length) { alert('No data for current week.'); return; }
  }

  // Gather all logs for this block
  const blockLogs = {};
  for (const [key, val] of Object.entries(state.logs)) {
    if (key.startsWith(blockId + '||')) blockLogs[key] = val;
  }

  if (!Object.keys(blockLogs).length) {
    alert('No logged data found for this program.');
    return;
  }

  const wb = XLSX.utils.book_new();

  // ── SHEET 1: CYCLE SUMMARY ────────────────────────────────────────────────
  const { rows: summaryRows, styleMap: summaryStyles } = buildSummarySheet(block, weeks, blockLogs, scope);
  const ws1 = XLSX.utils.aoa_to_sheet(summaryRows);
  applySheetFormatting(ws1, summaryRows, { minWidth: 12, maxWidth: 30, styleMap: summaryStyles });
  XLSX.utils.book_append_sheet(wb, ws1, 'Dashboard');

  // ── SHEET 2: WEEK-OVER-WEEK PROGRESSION ──────────────────────────────────
  const { rows: progressRows, styleMap: progressStyles } = buildProgressionSheet(block, weeks, blockLogs);
  const ws2 = XLSX.utils.aoa_to_sheet(progressRows);
  applySheetFormatting(ws2, progressRows, { minWidth: 8, maxWidth: 30, styleMap: progressStyles });
  XLSX.utils.book_append_sheet(wb, ws2, 'Progression');

  // ── SHEET 3: FULL LOG ─────────────────────────────────────────────────────
  const { rows: logRows, styleMap: logStyles } = buildFullLogSheet(block, weeks, blockLogs);
  const ws3 = XLSX.utils.aoa_to_sheet(logRows);
  applySheetFormatting(ws3, logRows, { minWidth: 8, maxWidth: 30, styleMap: logStyles });
  XLSX.utils.book_append_sheet(wb, ws3, 'Full Log');

  // Download
  const dateStr = new Date().toISOString().slice(0, 10);
  const safeName = block.name.replace(/[^a-z0-9]/gi, '-').toLowerCase();
  const scopeStr = scope === 'week' ? '-week' + (state.activeWeek + 1) : '';
  XLSX.writeFile(wb, `liftlog-${safeName}${scopeStr}-${dateStr}.xlsx`, { cellStyles: true });

  // Close picker
  document.querySelectorAll('.export-scope-picker').forEach(el => el.style.display = 'none');
}

function buildSummarySheet(block, weeks, blockLogs, scope) {
  const peakByGroup = { squat: null, bench: null, deadlift: null };
  const prMap = {};

  for (const [key, val] of Object.entries(blockLogs)) {
    const parts = key.split('||');
    if (parts.length < 5 || !parts[4].startsWith('s')) continue;
    const exName = parts[3];
    if (!isTracked(exName)) continue;
    const si = parseInt(parts[4].slice(1));
    const weight = val.actual ? parseFloat(val.actual) : getPrescribedWeight(parts[0], parts[1], parts[2], exName, si);
    if (!weight || isNaN(weight) || weight <= 0) continue;
    const reps = getSetReps(parts[0], parts[1], parts[2], exName, si);
    if (!reps) continue;
    const rpe = val.rpe ? parseFloat(val.rpe) : null;
    const result = calc1rm(weight, reps, rpe);
    if (!result) continue;
    // Projections: comp lifts only (not variations)
    const group = classifyLift(exName);
    if (group && group !== 'other' && isCompLift(exName)) {
      if (!peakByGroup[group] || result.value > peakByGroup[group]) peakByGroup[group] = result.value;
    }
    if (val.actual) {
      const existing = prMap[exName];
      if (!existing || result.value > existing.e1rm)
        prMap[exName] = { weight, reps, e1rm: result.value, week: parts[1] };
    }
  }

  let totalDays = 0, completedDays = 0;
  const complianceRows = [];
  for (const week of weeks) {
    const scheduled = week.days?.length || 0;
    let done = 0;
    for (const day of (week.days || [])) { if (isDayComplete(block, week, day)) done++; }
    totalDays += scheduled; completedDays += done;
    complianceRows.push([week.label, done + ' / ' + scheduled + ' days', Math.round(done/Math.max(scheduled,1)*100) + '%']);
  }
  const overallPct = totalDays > 0 ? Math.round((completedDays / totalDays) * 100) : 0;

  const rows = [];
  const styleMap = {};
  const scopeLabel = scope === 'week' ? (weeks[0]?.label || 'Week') : block.weeks.length + '-Week Program';
  const dateStr = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

  const r = () => rows.length; // current row index helper

  rows.push([block.name]);                                              styleMap[r()-1] = XLS.title;
  rows.push([scopeLabel + '  ·  ' + dateStr + '  ·  Compliance: ' + overallPct + '%']); styleMap[r()-1] = XLS.subtitle;
  rows.push([]);

  rows.push(['MEET PROJECTIONS']);                                      styleMap[r()-1] = XLS.section;
  rows.push(['Lift', 'Peak e1RM', 'Opener (90%)', '2nd (95%)', '3rd (101%)']); styleMap[r()-1] = XLS.colHead;

  let projTotal = 0;
  for (const [group, label] of [['squat','Squat'],['bench','Bench'],['deadlift','Deadlift']]) {
    const peak = peakByGroup[group];
    if (peak) {
      const opener = Math.round(peak * 0.90 / 2.5) * 2.5;
      const second = Math.round(peak * 0.95 / 2.5) * 2.5;
      const third  = Math.round(peak * 1.01 / 2.5) * 2.5;
      rows.push([label, Math.round(peak) + ' lbs', opener + ' lbs', second + ' lbs', third + ' lbs']);
      projTotal += third;
    } else {
      rows.push([label, 'No data', '—', '—', '—']);
    }
  }
  rows.push(['Projected Total', projTotal > 0 ? projTotal + ' lbs' : 'N/A', '', '', '']); styleMap[r()-1] = XLS.bold;
  rows.push([]);

  rows.push(['PERSONAL RECORDS']);                                      styleMap[r()-1] = XLS.section;
  rows.push(['Exercise', 'Weight', 'Reps', 'e1RM', 'Week']);           styleMap[r()-1] = XLS.colHead;
  const prEntries = Object.entries(prMap).sort((a, b) => b[1].e1rm - a[1].e1rm);
  if (prEntries.length) {
    for (const [name, pr] of prEntries)
      rows.push([name, pr.weight + ' lbs', pr.reps + ' reps', Math.round(pr.e1rm) + ' lbs', pr.week]);
  } else {
    rows.push(['No logged sets with actual weights found.', '', '', '', '']);
  }
  rows.push([]);

  rows.push(['COMPLIANCE BY WEEK']);                                    styleMap[r()-1] = XLS.section;
  rows.push(['Week', 'Days Completed', 'Rate']);                        styleMap[r()-1] = XLS.colHead;
  for (const cr of complianceRows) rows.push(cr);

  return { rows, styleMap };
}

function buildProgressionSheet(block, weeks, blockLogs) {
  const tracked = {};

  for (const [key, val] of Object.entries(blockLogs)) {
    const parts = key.split('||');
    if (parts.length < 5 || !parts[4].startsWith('s')) continue;
    const exName = parts[3];
    if (!isTracked(exName)) continue;
    const group = classifyLift(exName);
    if (!group) continue;
    const si = parseInt(parts[4].slice(1));
    const weight = val.actual ? parseFloat(val.actual) : getPrescribedWeight(parts[0], parts[1], parts[2], exName, si);
    if (!weight || isNaN(weight) || weight <= 0) continue;
    const reps = getSetReps(parts[0], parts[1], parts[2], exName, si);
    if (!reps) continue;
    const rpe = val.rpe ? parseFloat(val.rpe) : null;
    const result = calc1rm(weight, reps, rpe);
    if (!result) continue;
    if (!tracked[exName]) tracked[exName] = { group, weeks: {} };
    const weekLabel = parts[1];
    if (!tracked[exName].weeks[weekLabel])
      tracked[exName].weeks[weekLabel] = { e1rm: 0, topWeight: 0, topReps: 0, topRpe: null, tonnage: 0 };
    const w = tracked[exName].weeks[weekLabel];
    w.tonnage += weight * reps;
    if (result.value > w.e1rm) { w.e1rm = result.value; w.topWeight = weight; w.topReps = reps; w.topRpe = rpe; }
  }

  if (!Object.keys(tracked).length)
    return { rows: [['No tracked lifts with logged data found.']], styleMap: {} };

  const groupOrder = { squat: 0, bench: 1, deadlift: 2, other: 3 };
  const sortedExercises = Object.entries(tracked).sort((a, b) => {
    const go = (groupOrder[a[1].group] || 3) - (groupOrder[b[1].group] || 3);
    return go !== 0 ? go : a[0].localeCompare(b[0]);
  });

  const rows = [];
  const styleMap = {};
  const r = () => rows.length;

  rows.push(['WEEK-OVER-WEEK PROGRESSION']);             styleMap[r()-1] = XLS.title;
  rows.push(['All weights in lbs  ·  e1RM = estimated 1-rep max from top set']); styleMap[r()-1] = XLS.subtitle;
  rows.push([]);

  for (const [exName, data] of sortedExercises) {
    const weekData = data.weeks;
    if (!Object.keys(weekData).length) continue;

    rows.push([exName]);                                 styleMap[r()-1] = XLS.section;
    rows.push(['Week', 'Top Set', 'Reps', 'RPE', 'e1RM', '∆ e1RM', 'Volume (lbs)']); styleMap[r()-1] = XLS.colHead;

    const sortedWeeks = Object.entries(weekData).sort((a, b) => sessionOrder(a[0]) - sessionOrder(b[0]));
    let prevE1rm = null;
    for (const [weekLabel, w] of sortedWeeks) {
      const e1rmRounded = Math.round(w.e1rm);
      let deltaStr = '—';
      if (prevE1rm !== null) { const d = e1rmRounded - Math.round(prevE1rm); deltaStr = (d >= 0 ? '+' : '') + d; }
      rows.push([weekLabel, w.topWeight, w.topReps, w.topRpe !== null ? w.topRpe : '—', e1rmRounded, deltaStr, Math.round(w.tonnage)]);
      prevE1rm = w.e1rm;
    }
    rows.push([]);
  }

  return { rows, styleMap };
}

function buildFullLogSheet(block, weeks, blockLogs) {
  const rows = [];
  const styleMap = {};
  const r = () => rows.length;

  rows.push(['FULL TRAINING LOG']);                      styleMap[r()-1] = XLS.title;
  rows.push([block.name + '  ·  ' + weeks.length + ' week(s)']); styleMap[r()-1] = XLS.subtitle;
  rows.push([]);
  rows.push(['Week', 'Day', 'Exercise', 'Set', 'Prescribed', 'Logged (lbs)', 'RPE', 'Done']); styleMap[r()-1] = XLS.colHead;

  let lastWeek = null;
  for (const week of weeks) {
    for (const day of (week.days || [])) {
      for (const ex of (day.exercises || [])) {
        const sets = parseSets(ex.prescription) || [];
        const setCount = Math.max(sets.length, 1);
        for (let si = 0; si < setCount; si++) {
          const setKey = [block.id, week.label, day.name, ex.name, 's' + si].join('||');
          const log = blockLogs[setKey] || {};
          const prescribed = sets[si]
            ? (sets[si].isRpe ? `${sets[si].reps} @ RPE ${sets[si].rpe}` : `${sets[si].reps}×${sets[si].weight}`)
            : (ex.prescription || '');
          // Bold the week label cell when week changes
          if (week.label !== lastWeek && si === 0) {
            styleMap[r()] = XLS.bold;
            lastWeek = week.label;
          }
          rows.push([week.label, day.name, ex.name, si + 1, prescribed, log.actual || '', log.rpe || '', log.done ? '✓' : (log.skipped ? 'skip' : '')]);
        }
      }
    }
  }

  return { rows, styleMap };
}

function applySheetFormatting(ws, rows, opts = {}) {
  // Column widths
  const colWidths = [];
  rows.forEach(row => {
    row.forEach((cell, i) => {
      const len = String(cell || '').length;
      if (!colWidths[i] || colWidths[i] < len) colWidths[i] = len;
    });
  });
  ws['!cols'] = colWidths.map(w => ({
    wch: Math.min(Math.max(w + 2, opts.minWidth || 10), opts.maxWidth || 35)
  }));

  // Freeze top rows
  if (opts.freezeRows) {
    ws['!freeze'] = { xSplit: 0, ySplit: opts.freezeRows, topLeftCell: 'A' + (opts.freezeRows + 1), activeCell: 'A' + (opts.freezeRows + 1), sqref: 'A' + (opts.freezeRows + 1) };
  }

  // Apply cell styles based on row role markers
  if (!opts.styleMap) return;
  const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
  for (let R = range.s.r; R <= range.e.r; R++) {
    const style = opts.styleMap[R];
    if (!style) continue;
    for (let C = range.s.c; C <= range.e.c; C++) {
      const addr = XLSX.utils.encode_cell({ r: R, c: C });
      if (!ws[addr]) ws[addr] = { t: 's', v: '' };
      ws[addr].s = style;
    }
  }
}

function styleSheetHeaders(ws, rows) { applySheetFormatting(ws, rows); }

// Style presets
const XLS = {
  title:    { font: { bold: true, sz: 16 }, alignment: { vertical: 'center' } },
  subtitle: { font: { bold: false, sz: 11, color: { rgb: '888888' } } },
  section:  { font: { bold: true, sz: 12 } },
  colHead:  { font: { bold: true, sz: 11 } },
  bold:     { font: { bold: true, sz: 11 } },
  normal:   { font: { sz: 11 } },
};
render();

// ── CALCULATOR ────────────────────────────────────────────────────────────────
const KG_TO_LBS = 2.2046; // USPA standard conversion factor (1 kg = KG_TO_LBS lbs)
const KG_PLATES = [25, 20, 15, 10, 5, 2.5, 1.25, 0.5, 0.25];
const PLATE_COLORS = {
  25: '#e63946',
  20: '#1d7ed8',
  15: '#f4a228',
  10: '#2daa4f',
  5: '#d4d4d4',
  2.5: '#333333',
  1.25: '#aaaaaa',
  0.5: '#bbbbbb',
  0.25: '#cccccc'
};
const BAR_KG = 20;

const BARS = [
  { id: 'standard', label: 'Standard Bar', kg: 20, lbs: 44 },
  { id: 'squat',    label: 'Squat Bar',    kg: 25, lbs: 55 }
];
const COLLAR_KG = 5; // pair



function lbsToKg(lbs) { return lbs / KG_TO_LBS; }
function kgToLbs(kg) { return kg * KG_TO_LBS; }
function roundToNearest(val, step) { return Math.round(val / step) * step; }
// Snap a kg value to nearest valid USPA attempt (multiples of 2.5kg per side)
function snapToAttempt(kg, direction) {
  const base = getBaseKg();
  const load = Math.max(0, kg - base);
  let snapped;
  if (direction === 'up')        snapped = Math.ceil(load / 2.5) * 2.5;
  else if (direction === 'down') snapped = Math.floor(load / 2.5) * 2.5;
  else                           snapped = Math.round(load / 2.5) * 2.5;
  return base + snapped;
}

function getBarKg() { return BARS.find(b => b.id === state.calc.barId).kg; }
function getCollarKg() { return state.calc.collarsOn ? COLLAR_KG : 0; }
function getBaseKg() { return getBarKg() + getCollarKg(); }

// Given a target total kg, return {plates: [{kg, count}], totalKg, remainder}
function calcPlates(targetKg) {
  let loadKg = targetKg - getBaseKg();
  if (loadKg < 0) return null;
  let perSide = loadKg / 2;
  let remaining = perSide;
  let plates = [];
  for (const p of KG_PLATES) {
    if (remaining <= 0) break;
    const count = Math.floor(remaining / p + 0.001);
    if (count > 0) {
      plates.push({ kg: p, count });
      remaining -= count * p;
      remaining = Math.round(remaining * 1000) / 1000;
    }
  }
  const actualPerSide = plates.reduce((s, p) => s + p.kg * p.count, 0);
  const actualTotal = getBaseKg() + actualPerSide * 2;
  return { plates, totalKg: actualTotal, remainder: Math.round(remaining * 1000) / 1000 };
}

function manualTotal() {
  let perSide = 0;
  for (const [kg, count] of Object.entries(state.calc.manualCounts)) {
    perSide += parseFloat(kg) * count;
  }
  return getBaseKg() + perSide * 2;
}

function renderCalcBarSVG(plates, showCollars) {
  let allPlates = [];
  for (const p of plates) {
    for (let i = 0; i < p.count; i++) allPlates.push(p.kg);
  }

  function pThick(kg) {
    if (kg >= 25) return 16; if (kg >= 20) return 15; if (kg >= 15) return 13;
    if (kg >= 10) return 12; if (kg >= 5) return 10; if (kg >= 2.5) return 9;
    if (kg >= 1.25) return 11; if (kg >= 0.5) return 9; return 7;
  }
  function pDiam(kg) {
    if (kg >= 25) return 190; if (kg >= 20) return 172; if (kg >= 15) return 152;
    if (kg >= 10) return 130; if (kg >= 5)  return 104; if (kg >= 2.5) return 82;
    if (kg >= 1.25) return 64; if (kg >= 0.5) return 48; return 36;
  }

  const SVG_H = 240;
  const cy = SVG_H / 2 - 10;
  const barH = 10;
  const divider = 1;
  const padLeft = 8;

  const builtinCollarThick = 10;
  const builtinCollarH = 26;
  const compCollarThick = 14;
  const compCollarH = 38;

  // Shaft extends to fill container — always show generous bar to the right
  let totalPlateW = allPlates.reduce((s, kg) => s + pThick(kg), 0);
  if (allPlates.length > 1) totalPlateW += divider * (allPlates.length - 1);
  const compCollarW = showCollars ? compCollarThick + 3 : 0;
  const minRightShaft = 80; // always show this much empty bar after plates
  const contentW = padLeft + builtinCollarThick + totalPlateW + compCollarW + minRightShaft;
  const SVG_W = Math.max(contentW, 220);

  let parts = [];

  // Bar shaft — full width
  parts.push(`<rect x="${padLeft}" y="${cy - barH/2}" width="${SVG_W - padLeft}" height="${barH}" rx="3" fill="#555"/>`);
  parts.push(`<rect x="${padLeft}" y="${cy - barH/2}" width="${SVG_W - padLeft}" height="3" rx="1" fill="rgba(255,255,255,0.08)"/>`);

  let x = padLeft;

  // Built-in collar
  parts.push(`<rect x="${x}" y="${cy - builtinCollarH/2}" width="${builtinCollarThick}" height="${builtinCollarH}" rx="2" fill="#6a6a6a" stroke="rgba(0,0,0,0.4)" stroke-width="0.5"/>`);
  parts.push(`<rect x="${x+1}" y="${cy - builtinCollarH/2 + 1}" width="${builtinCollarThick-2}" height="2" rx="1" fill="rgba(255,255,255,0.12)"/>`);
  parts.push(`<line x1="${x+2}" y1="${cy - builtinCollarH/2 + 4}" x2="${x+builtinCollarThick-2}" y2="${cy - builtinCollarH/2 + 4}" stroke="rgba(0,0,0,0.3)" stroke-width="1"/>`);
  parts.push(`<line x1="${x+2}" y1="${cy + builtinCollarH/2 - 4}" x2="${x+builtinCollarThick-2}" y2="${cy + builtinCollarH/2 - 4}" stroke="rgba(0,0,0,0.3)" stroke-width="1"/>`);
  x += builtinCollarThick;

  // Plates
  for (let i = 0; i < allPlates.length; i++) {
    const kg = allPlates[i];
    const pt = pThick(kg);
    const ph = pDiam(kg);
    const color = PLATE_COLORS[kg];

    if (i > 0) {
      parts.push(`<rect x="${x}" y="${cy - pDiam(allPlates[i-1])/2}" width="1" height="${pDiam(allPlates[i-1])}" fill="rgba(0,0,0,0.6)"/>`);
      x += divider;
    }

    parts.push(`<rect x="${x}" y="${cy - ph/2}" width="${pt}" height="${ph}" rx="2" fill="${color}" stroke="rgba(0,0,0,0.3)" stroke-width="0.5"/>`);
    parts.push(`<rect x="${x+1}" y="${cy - ph/2 + 1}" width="${pt-2}" height="2" rx="1" fill="rgba(255,255,255,0.18)"/>`);
    parts.push(`<rect x="${x+1}" y="${cy + ph/2 - 3}" width="${pt-2}" height="2" rx="1" fill="rgba(0,0,0,0.2)"/>`);

    // Uniform label below every plate
    const labelY = cy + ph/2 + 14;
    parts.push(`<text x="${x + pt/2}" y="${labelY}" text-anchor="middle" dominant-baseline="central" fill="#ccc" font-family="Barlow Condensed, sans-serif" font-weight="700" font-size="11">${kg}</text>`);

    x += pt;
  }

  // Competition collar
  if (showCollars) {
    const cx2 = x;
    parts.push(`<rect x="${cx2}" y="${cy - compCollarH/2}" width="${compCollarThick}" height="${compCollarH}" rx="3" fill="#999" stroke="rgba(0,0,0,0.45)" stroke-width="0.75"/>`);
    parts.push(`<rect x="${cx2+1}" y="${cy - compCollarH/2 + 2}" width="${compCollarThick-2}" height="3" rx="1" fill="rgba(255,255,255,0.15)"/>`);
    parts.push(`<rect x="${cx2+2}" y="${cy-5}" width="${compCollarThick-4}" height="10" rx="2" fill="#777"/>`);
    parts.push(`<circle cx="${cx2 + compCollarThick/2}" cy="${cy}" r="3.5" fill="#555"/>`);
    parts.push(`<circle cx="${cx2 + compCollarThick/2}" cy="${cy}" r="1.5" fill="#888"/>`);
    const handleX = cx2 + compCollarThick/2;
    const handleBaseY = cy - compCollarH/2;
    parts.push(`<rect x="${handleX-2.5}" y="${handleBaseY-18}" width="5" height="18" rx="2" fill="#888"/>`);
    parts.push(`<ellipse cx="${handleX}" cy="${handleBaseY-18}" rx="3.5" ry="3" fill="#111"/>`);
    parts.push(`<circle cx="${handleX}" cy="${handleBaseY}" r="3" fill="#666"/>`);
    parts.push(`<circle cx="${handleX}" cy="${handleBaseY}" r="1.5" fill="#aaa"/>`);
  }

  // viewBox anchored to left edge (collar), width fills container
  return `<svg viewBox="0 0 ${SVG_W} ${SVG_H}" width="100%" height="${SVG_H}" style="display:block" xmlns="http://www.w3.org/2000/svg">${parts.join('')}</svg>`;
}
function renderCalc() {
  const main = document.getElementById('main-content');
  const { mode, inputUnit, inputVal, manualCounts } = state.calc;

  let totalKg = 0, totalLbs = 0, plates = [], remainder = 0, noSolution = false;

  if (mode === 'target') {
    const numVal = parseFloat(inputVal);
    if (!isNaN(numVal) && numVal > 0) {
      let rawKg = inputUnit === 'lbs' ? lbsToKg(numVal) : numVal;
      // Round the *load* UP to the nearest 2.5kg step (= 1x 1.25kg plate per side, standard minimum)
      // Always round UP — entering 440 lbs should never give you less than 440 lbs
      let targetKg = snapToAttempt(rawKg);
      const baseKg = getBaseKg();
      if (targetKg < baseKg) targetKg = baseKg;
      const result = calcPlates(targetKg);
      if (result) {
        plates = result.plates;
        totalKg = result.totalKg;
        totalLbs = kgToLbs(totalKg);
        remainder = result.remainder;
        if (remainder > 0.01) noSolution = true;
      }
    }
  } else {
    totalKg = manualTotal();
    totalLbs = kgToLbs(totalKg);
    plates = KG_PLATES
      .map(kg => ({ kg, count: manualCounts[kg] || 0 }))
      .filter(p => p.count > 0);
  }

  const hasPlates = plates.some(p => p.count > 0);
  const barSVG = renderCalcBarSVG(plates, state.calc.collarsOn);

  // Plate breakdown chips (for target mode)
  let breakdownHtml = '';
  if (hasPlates) {
    breakdownHtml = `<div class="calc-plate-breakdown">`;
    for (const p of plates) {
      if (p.count === 0) continue;
      const total = p.count * 2; // both sides
      breakdownHtml += `<div class="calc-plate-chip">
        <div class="calc-plate-dot" style="background:${PLATE_COLORS[p.kg]}"></div>
        <span class="calc-plate-label">${p.kg}kg</span>
        <span class="calc-plate-count">×${p.count} per side</span>
      </div>`;
    }
    breakdownHtml += `</div>`;
  }

  // Manual plate rows
  let manualRowsHtml = '';
  const manualPlateOrder = [25, 2.5, 20, 1.25, 15, 0.5, 10, 0.25, 5];
  for (const kg of manualPlateOrder) {
    const count = manualCounts[kg] || 0;
    manualRowsHtml += `
      <div class="calc-plate-row">
        <div class="calc-plate-color-swatch" style="background:${PLATE_COLORS[kg]}"></div>
        <span class="calc-plate-name">${kg}kg</span>
        <div class="calc-plate-stepper">
          <button class="calc-stepper-btn" onclick="calcAdjust(${kg}, -1)">−</button>
          <span class="calc-stepper-val${count === 0 ? ' zero' : ''}">${count}</span>
          <button class="calc-stepper-btn" onclick="calcAdjust(${kg}, 1)">+</button>
        </div>
      </div>`;
  }

  const bar = BARS.find(b => b.id === state.calc.barId);
  const collarNote = state.calc.collarsOn ? ` + collars (5kg)` : '';
  const plateNote = hasPlates ? ` + ${plates.map(p => `${p.count}×${p.kg}kg`).join(' + ')} per side` : '';

  // Attempt snaps for target mode
  const snapHtml = (mode === 'target' && inputUnit === 'lbs' && inputVal && !isNaN(parseFloat(inputVal))) ? (() => {
    const rounded = snapToAttempt(lbsToKg(parseFloat(inputVal)));
    const roundedLbs = (rounded * KG_TO_LBS).toFixed(1);
    const roundedDisplay = rounded % 1 === 0 ? rounded.toFixed(0) : rounded.toFixed(1);
    const down = rounded - 2.5; const up = rounded + 2.5;
    const downLbs = (down * KG_TO_LBS).toFixed(1); const upLbs = (up * KG_TO_LBS).toFixed(1);
    const downDisplay = down % 1 === 0 ? down.toFixed(0) : down.toFixed(1);
    const upDisplay = up % 1 === 0 ? up.toFixed(0) : up.toFixed(1);
    return `<div style="display:flex;align-items:center;justify-content:center;gap:6px;margin-top:8px;flex-wrap:wrap;">
      <div onclick="calcSnapToNearest(${down})" style="display:flex;align-items:center;gap:3px;cursor:pointer;background:#1a1a1a;border:1px solid #2a2a2a;border-radius:8px;padding:4px 8px;font-size:11px;color:#888;">
        <span style="color:#C9A84C;font-size:13px;">−</span><span>${downDisplay}kg</span><span style="color:#555;font-size:10px;">${downLbs}</span>
      </div>
      <div onclick="calcSnapToNearest(${rounded})" style="display:flex;align-items:center;gap:3px;cursor:pointer;background:#1e1c18;border:1px solid #C9A84C55;border-radius:8px;padding:4px 8px;font-size:11px;color:#C9A84C;font-weight:600;">
        <span>→ ${roundedDisplay}kg</span><span style="color:#888;font-size:10px;">${roundedLbs}</span>
      </div>
      <div onclick="calcSnapToNearest(${up})" style="display:flex;align-items:center;gap:3px;cursor:pointer;background:#1a1a1a;border:1px solid #2a2a2a;border-radius:8px;padding:4px 8px;font-size:11px;color:#888;">
        <span style="color:#C9A84C;font-size:13px;">+</span><span>${upDisplay}kg</span><span style="color:#555;font-size:10px;">${upLbs}</span>
      </div>
    </div>`;
  })() : '';

  let html = `<div class="calc-screen">

    <!-- ── MODE TOGGLE + INPUT (top, always visible) ── -->
    <div class="calc-section" style="padding:12px;">
      <div class="calc-mode-toggle" style="margin-bottom:10px;">
        <button class="calc-mode-btn${mode === 'target' ? ' active' : ''}" onclick="calcSetMode('target')">Target Weight</button>
        <button class="calc-mode-btn${mode === 'manual' ? ' active' : ''}" onclick="calcSetMode('manual')">Load Manually</button>
      </div>

      ${mode === 'target' ? `
        <div class="calc-mode-toggle" style="margin-bottom:10px;">
          <button class="calc-mode-btn${inputUnit === 'lbs' ? ' active' : ''}" onclick="calcSetUnit('lbs')">LBS</button>
          <button class="calc-mode-btn${inputUnit === 'kg' ? ' active' : ''}" onclick="calcSetUnit('kg')">KG</button>
        </div>
        <div class="calc-input-row" style="margin-bottom:0;">
          <input class="calc-weight-input" id="calc-input" type="number" inputmode="decimal" placeholder="0" value="${inputVal}" onblur="calcInput(this.value)" onkeydown="if(event.key==='Enter'){this.blur()}" style="width:100%;" />
        </div>
        ${snapHtml}
      ` : ''}
    </div>

    <!-- ── BAR VISUAL + TOTALS ── -->
    <div class="calc-section" style="padding:12px 12px 10px;">
      <div class="calc-totals-display" style="margin-bottom:10px;">
        <div class="calc-total-box">
          <div class="calc-total-val">${totalKg % 1 === 0 ? totalKg.toFixed(0) : totalKg.toFixed(1)}</div>
          <div class="calc-total-unit">Kilograms</div>
        </div>
        <div class="calc-total-box">
          <div class="calc-total-val">${totalLbs.toFixed(1)}</div>
          <div class="calc-total-unit">Pounds</div>
        </div>
      </div>
      <div class="calc-bar-wrap">${barSVG}</div>
      ${noSolution ? `<div class="calc-no-solution"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> Weight not achievable with standard KG plates</div>` : ''}
      ${breakdownHtml}
      <div class="calc-bar-note">${bar.label} (${bar.kg}kg)${collarNote}${plateNote || ' — bar only'}</div>
    </div>

    <!-- ── SECONDARY CONTROLS ── -->
    <div class="calc-section" style="padding:12px;">
      <div class="calc-bar-selector" style="margin-bottom:10px;">
        ${BARS.map(b => `<button class="calc-bar-btn${state.calc.barId === b.id ? ' active' : ''}" onclick="calcSetBar('${b.id}')">
          ${b.label}<span class="calc-bar-btn-sub">${b.kg}kg / ${b.lbs}lbs</span>
        </button>`).join('')}
      </div>
      <div class="calc-collar-row" style="margin-bottom:${mode === 'manual' ? '12px' : '0'};">
        <div>
          <div class="calc-collar-label">Collars</div>
          <div class="calc-collar-sub">2.5kg each · 5kg / 11lbs total</div>
        </div>
        <button class="calc-collar-toggle${state.calc.collarsOn ? ' on' : ''}" onclick="calcToggleCollars()"></button>
      </div>
      ${mode === 'manual' ? `
        <div class="calc-section-title" style="margin-bottom:10px;">Plates (per side)</div>
        <div class="calc-plates-grid">${manualRowsHtml}</div>
        <button class="calc-reset-btn" onclick="calcReset()">Clear All Plates</button>
      ` : ''}
    </div>

  </div>`;
  main.innerHTML = html;
}

function calcSnapToNearest(targetKg) {
  // Populate input with the nearest valid attempt value
  // Convert back to whatever unit is currently selected
  if (state.calc.inputUnit === 'lbs') {
    const lbs = Math.round(targetKg * KG_TO_LBS * 10) / 10;
    state.calc.inputVal = String(lbs);
  } else {
    state.calc.inputVal = String(targetKg % 1 === 0 ? targetKg : targetKg.toFixed(1));
  }
  const inp = document.getElementById('calc-weight-input');
  if (inp) inp.value = state.calc.inputVal;
  renderCalc();
}

function calcSetMode(m) { state.calc.mode = m; renderCalc(); }
function calcSetUnit(u) { state.calc.inputUnit = u; renderCalc(); }
function calcInput(v) { state.calc.inputVal = v; renderCalc(); }
function calcSetBar(id) { state.calc.barId = id; renderCalc(); }
function calcToggleCollars() { state.calc.collarsOn = !state.calc.collarsOn; renderCalc(); }
function calcAdjust(kg, delta) {
  const cur = state.calc.manualCounts[kg] || 0;
  state.calc.manualCounts[kg] = Math.max(0, cur + delta);
  renderCalc();
}
function calcReset() {
  for (const kg of KG_PLATES) state.calc.manualCounts[kg] = 0;
  renderCalc();
}
</script>
</body>
</html>